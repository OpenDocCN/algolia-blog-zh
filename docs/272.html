<html>
<head>
<title>Building a Store Locator in React using Algolia, Mapbox, and Twilio – Part 3 | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Algolia、Mapbox和Twilio在React中构建商店定位器——第3部分</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-3/#0001-01-01">https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-3/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="c9 translated">本文完成了构建商店定位器的3部分系列。请务必查看<span class="c3"> <a class="c22" href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-1/">构建商店定位器-第1部分</a> </span>和<span class="c3"> <a class="c22" href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-2/">构建商店定位器-第2部分</a> </span>。</p>
<p class="c31 c41 c21 translated"><span class="c0">如今，电子商务购物者期望便利，希望现实世界和网络世界融合，允许他们通过任何渠道开展业务。这就是商店定位器的用途，这样用户就可以:</span></p>
<ul class="c24 lst-kix_wn654b2v1p67-0">
<li class="c31 c1 c21 li-bullet-0 translated"><span class="c0">在线搜索产品，然后在店内购买</span></li>
<li class="c31 c1 c21 li-bullet-0 translated"><span class="c0">亲自浏览和比较产品，然后在线购买</span></li>
<li class="c8 li-bullet-0 translated"><span class="c0">在网上购物并购买产品，然后亲自提货</span></li>
<li class="c8 li-bullet-0 translated"><span class="c0">亲自退还之前购买的物品，而不是将它们寄回</span></li>
</ul>
<p class="c31 c44 translated"><span class="c0">尽管如此，我们发现太多的网站没有为用户提供一种优雅的方式来找到他们的“最近的商店”，无论是测试、线下购买还是在线购买。</span></p>
<p class="c9 translated">构建商店定位器似乎很复杂，因为它需要实施地理搜索、地址/兴趣点(POI)搜索，并在地图上显示结果。为了让每个人尽可能容易地理解，我们将在React  <span class="c0">中创建一个<span class="c11">商店定位器，分三次现场编码会议，并附有三篇博文，使用:</span></span></p>
<ul class="c24 lst-kix_usw8mhw65v71-0">
<li class="c1 c21 li-bullet-0 translated"><span class="c3"> <a class="c22" href="https://www.algolia.com/">阿哥利亚</a>，因其</span> <span class="c0">的地缘搜索能力</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c3"> <a class="c22" href="https://www.mapbox.com/use-cases/store-locator/">地图框</a>，</span>，<span class="c0">用于显示地图和搜索地点和兴趣点</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c3"> <a class="c22" href="https://www.twilio.com/sms/"> Twilio，</a> </span> <span class="c0">用于在订单准备就绪后发送文本</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c3"> <a class="c22" href="https://www.clever-cloud.com/">【颖云】</a></span><span class="c0">为主持</span></li>
</ul>
<h2 id="h.o24qypvvlk7k" class="c15 translated">到目前为止我们所看到的</h2>
<p class="c9 translated"><span class="c3"> <a class="c22" href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-1/">在第1部分</a> </span>中，我们创建了所有必需的帐户，搭建了React项目，并在Algolia索引中用我们的商店索引数据集，然后通过配置其文本和业务相关性来结束。</p>
<p class="c9 translated"><span class="c3"> <a class="c22" href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-2/">在第2部分</a> </span>中，我们在应用程序中添加了地理搜索功能，使用Algolia，React InstantSearch和Mapbox，在连接到Algolia的<a href="https://www.algolia.com/doc/guides/building-search-ui/what-is-instantsearch/js/"> InstantSearch </a>的地图上显示结果，这要归功于<span class="c3 c6"><a class="c22" href="https://www.algolia.com/doc/api-reference/widgets/geo-search/js/%23connector">connectGeoSearch</a></span><span class="c0">高阶组件。我们还增加了“移动地图时搜索”选项，类似于你在Airbnb或GetAround上可以找到的选项。</span></p>
<h3 class="translated"><a id="todays-focus" class="anchor" href="#todays-focus" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span class="c45 c47">今日关注</span></h3>
<p class="translated"><iframe src="https://www.youtube.com/embed/rKFMPYDwOn4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen">视频</iframe></p>
<p class="c9 translated"><span class="c0">为了完成这个系列，我们要做以下事情:</span></p>
<ul class="c24 lst-kix_pxhogv66n02a-0 start">
<li class="c1 c21 li-bullet-0 translated">使用<span class="c3"><a class="c22" href="https://github.com/algolia/autocomplete/">Algolia Autocomplete</a></span>和<span class="c3"> <a class="c22" href="https://docs.mapbox.com/api/search/geocoding/"> Mapbox地理编码API </a>，</span>添加一个自动完成下拉菜单，允许用户<span class="c0">查找城市周围最近的商店，同时查找商店本身</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">添加短信提醒功能，通知用户产品是否可以提货，类似于宜家在线购买、店内提货(BOPIS)功能</span></li>
</ul>
<p class="c9 translated"><span class="c0">代码可以在项目的Github库中找到:</span></p>

<h2 id="h.ywnqwih5bmqu" class="c9 c50 translated"><span class="c40">添加自动完成功能</span></h2>
<h3 id="h.cuemcl3d707u" class="c15 translated">自动完成体验</h3>
<p class="c9 translated">在任何网站或应用程序中，自动完成都是用户旅程中至关重要的一部分，因为它能有效地引导用户。您的用户不必知道他们要查找的确切术语——他们可以键入几个字母，自动完成菜单会显示可用的搜索选项，随时可供选择。</p>
<p class="c9 translated">它可能在电子商务平台、搜索引擎或地图上，在那里你不再需要知道完整的地址。</p>
<p class="translated"><video poster="https://res.cloudinary.com/hilnmyskv/image/upload/v1632761602/blogposts/store_locator_2021_autocomplete-is-everywhere.jpg" autoplay="autoplay" loop="loop" muted="muted"> <span data-mce-type="bookmark" class="mce_SELRES_start"> </span> <source type="video/mp4" src="https://res.cloudinary.com/hilnmyskv/image/upload/v1632761602/blogposts/store_locator_2021_autocomplete-is-everywhere.mp4"/> <source type="video/webm" src="https://res.cloudinary.com/hilnmyskv/image/upload/v1632761602/blogposts/store_locator_2021_autocomplete-is-everywhere.webm"/></video></p>
<h3 class="translated"><a id="what-is-algolia-autocomplete" class="anchor" href="#what-is-algolia-autocomplete" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span class="c45 c47">什么是Algolia自动完成？</span></h3>
<p class="c9 translated"><span class="c3"><a class="c22" href="https://www.algolia.com/doc/ui-libraries/autocomplete/introduction/what-is-autocomplete/">Algolia Autocomplete</a></span><span class="c0">是一个免费开源的JavaScript库。我们最近对它进行了彻底的重构，以交付最佳的开发人员体验，重点是用自动完成UX模式创建流畅的搜索体验。</span></p>
<p class="c9 translated"><span class="c0">通过设计，它提供了一种在多个来源中进行搜索的简单方法，这些来源可以是Algolia索引或外部API。构建联合搜索体验从未如此简单。</span></p>
<p class="c9 translated"><span class="c0">今天，我们将为自动完成插件创建并添加两个源代码，这样你就可以在自己的代码库中重用它们:</span></p>
<ul class="c24 lst-kix_fqtui8czbcy2-0 start">
<li class="c1 c21 li-bullet-0 translated"><span class="c0">第一个数据源的目标是Algolia索引中的商店，因此用户可以根据商店的名称或城市来搜索商店</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">第二个来源以Mapbox地理编码API为目标，因此用户可以在世界各地搜索任何可用的城市或兴趣点</span></li>
</ul>
<p class="c9 translated">在我们的项目中，我们使用自动完成来搜索位置和商店。如上所述，它可以以许多其他方式使用，例如，通过<span class="c3"><a class="c22" href="https://docsearch.algolia.com/">Algolia DocSearch</a></span>项目增强文档网站上的搜索体验，您可以在<span class="c3"> <a class="c22" href="https://tailwindcss.com/docs&amp;sa=D&amp;source=editors"> TailwindCSS </a> </span>、<span class="c3"> <a class="c22" href="https://reactjs.org/docs/getting-started.html"> React </a>、</span>或<span class="c3"> <a class="c22" href="https://www.twilio.com/docs"> Twilio </a> </span> <span class="c0">等网站上找到该项目。</span></p>
<h3 id="h.q85nextnmz84" class="c15 translated"><span class="c45 c47">安装AutocompleteJS </span></h3>
<p class="c9 translated"><span class="c0">我们先安装需要的包:</span></p>
<pre class="lang:sh decode:true ">$ yarn add @algolia/autocomplete-js @algolia/autocomplete-theme-classic&#13;
</pre>
<p class="translated">让我们也安装一下<code>@algolia/autocomplete-plugin-query-suggestions</code>，因为我们一会儿就要用到它。</p>
<p class="translated">现在，让我们创建一个<code>&lt;Autocomplete/&gt;</code>组件。</p>
<p class="translated">在这里，我们不会深入细节，但是你可以在文档中找到关于这个组件的所有信息。</p>
<p class="translated">这里你唯一应该注意的是展开操作符……<code><strong>props</strong></code>，它将允许我们在组件初始化上展开更多的道具。</p>
<h4 class="c9 translated"><strong> <span class="c5">组件/自动完成/Autocomplete.tsx </span> </strong></h4>
<pre class="lang:js decode:true">import React, { createElement, Fragment, useEffect, useRef } from 'react';&#13;
import { autocomplete, AutocompleteOptions } from '@algolia/autocomplete-js';&#13;
import { render } from 'react-dom';&#13;
&#13;
type Optional&lt;TObject, TKeys extends keyof TObject&gt; = Partial&lt;&#13;
  Pick&lt;TObject, TKeys&gt;&#13;
  &gt; &amp;&#13;
  Omit&lt;TObject, TKeys&gt;;&#13;
&#13;
function Autocomplete = any&gt;(&#13;
  props: Optional&lt;&#13;
    AutocompleteOptions,&#13;
    'container' | 'renderer' | 'render'&#13;
  &gt;&#13;
  ) {&#13;
  const containerRef = useRef(null);&#13;
&#13;
  useEffect(() =&gt; {&#13;
      if (!containerRef.current) {&#13;
        return undefined;&#13;
      }&#13;
&#13;
    const search = autocomplete({&#13;
          container: containerRef.current!,&#13;
          renderer: { createElement, Fragment },&#13;
          render({ children }, root) {&#13;
            //@ts-ignore&#13;
            render(children, root);&#13;
          },&#13;
          ...props,&#13;
        });&#13;
&#13;
    return () =&gt; {&#13;
          search.destroy();&#13;
        };&#13;
      }, []);&#13;
&#13;
  return &lt;div className={'w-full'} ref={containerRef} /&gt;;&#13;
}&#13;
&#13;
export default Autocomplete;&#13;
</pre>
<p class="translated">现在，让我们把它作为一个孩子添加到我们的<code>Header</code>组件中。</p>
<p class="translated">首先，让我们更新我们的<code>header</code>组件，让它处理子组件。</p>
<h4 class="translated"><strong>Components/Header/Header . tsx</strong></h4>
<pre class="lang:js decode:true">const Header: React.FC = ({ children }) =&gt; {&#13;
return (&#13;
  &lt;header className={“...''}&gt;&#13;
    &lt;Logo className={'w-auto h-16'} /&gt;&#13;
    &lt;div className={'sm:w-full md:w-1/2'}&gt;{children}&lt;/div&gt;&#13;
  &lt;/header&gt;&#13;
  );&#13;
};&#13;
</pre>
<p class="translated">然后，让我们将刚刚创建的<code>&lt;Autocomplete/&gt;</code>组件添加到我们的<code><strong>App.tsx file</strong></code>中的这个头部</p>
<h4 class="c9 translated"><strong> <span class="c5">组件/App/App.tsx </span> </strong></h4>
<pre class="lang:js decode:true ">…&#13;
&lt;div className="App flex flex-col w-screen h-screen mx-auto bg-gray-50"&gt;&#13;
  &lt;Header&gt;&#13;
    {&lt;Autocomplete&#13;
      initialState={{&#13;
        query: searchState.query,&#13;
      }}&#13;
      placeholder={'Enter address, zip code or store name'}&#13;
      openOnFocus={true}&#13;
      onStateChange={onSubmit}&#13;
      onSubmit={onSubmit}&#13;
      onReset={onReset}&#13;
      plugins={plugins}&#13;
    /&gt;}&#13;
  &lt;/Header&gt;&#13;
&#13;
  &lt;div&#13;
    className={&#13;
      'sm:flex md:hidden w-full uppercase text-xl font-sans font-bold text-bold gap-4'&#13;
    }&#13;
  &gt;&#13;
…&#13;
</pre>
<p class="translated">自动完成组件接受这些属性:</p>
<ul>
<li class="translated">搜索输入的<code>placeholder</code>文本</li>
<li class="translated">如果搜索字段被聚焦，<code>openOnFocus={true}</code>将打开内容面板。</li>
<li class="translated">每当autocomplete中的内容发生变化时，就会触发<code>onStateChange={onSubmit}</code></li>
<li class="translated">当您按下“enter”键或选择一个结果时，会触发<code>onSubmit={onSubmit}</code></li>
<li class="translated">点击输入中的x按钮时会触发<code>onReset={onReset}</code></li>
</ul>
<p class="translated">这些方法负责更新状态:</p>
<pre class="lang:js decode:true">// Handle search results updates&#13;
const onSubmit = useCallback(({ state }) =&gt; {&#13;
  setSearchState((searchState) =&gt; ({&#13;
    ...searchState,&#13;
    query: state.query,&#13;
  }));&#13;
  }, []);&#13;
&#13;
// Click on the little cross on autocomplete field&#13;
const onReset = useCallback(() =&gt; {&#13;
  setSearchState((searchState) =&gt; ({&#13;
    ...searchState,&#13;
    query: '',&#13;
  }));&#13;
}, []);&#13;
</pre>
<p class="c9 translated"><span class="c23">T</span><span class="c23">he</span><span class="c3 c5 c23"><a class="c22" href="https://reactjs.org/docs/hooks-reference.html%23usecallback">use callback</a></span><span class="c23">hook</span><span class="c64 c23">返回一个</span> <span class="c3 c64 c23"> <a class="c22" href="https://en.wikipedia.org/wiki/Memoization&amp;sa=D&amp;source=editors">内存化的</a> </span> <span class="c23 c64">版本的回调，只有当其中一个依赖关系发生变化时，该版本才会发生变化。这有助于防止不必要的渲染。</span></p>
<h3 id="h.zf2c6ny3mp6h" class="c15 translated"><span class="c45 c47">添加createquerysuggestionplugin</span></h3>
<p class="c9 translated">现在我们已经设置好了场景，是时候用数据填充自动完成组件了。您可以使用插件从许多来源获取数据:比如您自己的数据库、第三方API和Algolia。Algolia为一些数据源提供了<span class="c3"> <a class="c22" href="https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/autocomplete-js/">官方插件</a> </span> <span class="c0">，例如，一个Algolia索引。</span></p>
<p class="c9 translated"><span class="c0">对于我们的应用程序，我们将创建两个插件:</span></p>
<ul class="c24 lst-kix_9fbfmwfkis6k-0 start">
<li class="c1 c21 li-bullet-0 translated"><span class="c0"> <code>createSuggestionsPlugin</code> </span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0"> <code>mapboxGeocodingPlugin</code> </span></li>
</ul>
<p class="c9 translated">我们在<span class="c27"> <code>src/</code> </span>下新建一个文件夹，命名为<span class="c27"> <code>AutocompletePlugins</code> </span> <span class="c0">。</span></p>
<p class="c9 translated">我们将创建一个名为<code>createSuggestionsPlugin</code>的函数，它将是Algolia在<code>@algolia/autocomplete-plugin-query-suggestions</code>包中提供的<code>createQuerySuggestionsPlugin</code>的包装器。这样，我们可以扩展和丰富默认插件的行为，以便在我们的Algolia商店索引中进行搜索。</p>
<pre class="lang:js decode:true ">const createSuggestionsPlugin = (&#13;
  searchClient: SearchClient,&#13;
  indexName: string,&#13;
  onSelectHandler: (query: string) =&gt; void,&#13;
  onClick: (item: any) =&gt; void,&#13;
  HitComponent: React.ComponentType&#13;
  ) =&gt; {&#13;
  return createQuerySuggestionsPlugin({&#13;
    searchClient,&#13;
    indexName,&#13;
    transformSource({ source }) {&#13;
      return {&#13;
        ...source,&#13;
        sourceId: 'AlgoliaStores',&#13;
        onSelect(params) {&#13;
          onSelectHandler(params.item.query);&#13;
        },&#13;
        templates: {&#13;
          item({ item, components }: { item: any; components: any }) {&#13;
            return &lt;HitComponent item={item} onClick={onClick} components={components} /&gt;;&#13;
          },&#13;
        },&#13;
      };&#13;
    },&#13;
  });&#13;
  };&#13;
&#13;
export { createSuggestionsPlugin };&#13;
</pre>
<p class="c9 translated"><span class="c0">我们的函数取:</span></p>
<ul class="c24 lst-kix_glrc2sfc1924-0 start">
<li class="c1 c21 li-bullet-0 translated"><span class="c0">一个AlgoliaSearch客户端(我们在<a href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-2/">博客文章2 </a>中创建的)</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">一个索引名(相同)</span></li>
<li class="c1 c21 li-bullet-0 translated">一个<span class="c27"> <code>HitComponent</code> </span>，它与我们在第2部分中用来渲染侧边栏中每个点击<span class="c0">的组件是同一个组件</span></li>
<li class="c1 c21 li-bullet-0 translated">一个<span class="c27"> <code>onClick</code> </span>处理程序，用来映射当用户点击<code>HitComponent</code>时哪个函数被调用</li>
<li class="c1 c21 li-bullet-0 translated"><span class="c27">、</span>、<span class="c0">负责更新搜索输入的状态。</span></li>
</ul>
<p class="c9 translated">搜索客户端和索引名称在方法初始化中调用，其他的在插件的<span class="c27"> <code>transformSource</code> </span> <span class="c0">函数中使用，该函数负责在从我们的远程源(这里是Algolia API)检索到数据后转换数据。</span></p>
<p class="c9 translated"><span class="c0">现在，让我们将这个插件添加到我们的<code>Autocomplete</code>实例中，并检查一切是否如预期的那样工作。</span></p>
<pre class="lang:js decode:true">// Memoize plugins to then leverage useCallback hooks&#13;
const plugins = useMemo(() =&gt; {&#13;
  const querySuggestionPlugin = createSuggestionsPlugin(&#13;
    searchClient,&#13;
    indexName as string,&#13;
    (query) =&gt; {&#13;
      setSearchState((searchState) =&gt; ({&#13;
        ...searchState,&#13;
        query: query,&#13;
      }));&#13;
    },&#13;
    (item) =&gt; console.log(item),&#13;
    SuggestionComponent&#13;
  );&#13;
&#13;
  return [querySuggestionPlugin];&#13;
}, []);&#13;
</pre>
<p class="c9 translated"><span class="c45 c23">如果我们刷新浏览器，当我们在搜索输入中键入时，我们应该会看到商店名称，这意味着我们的插件功能齐全！</span></p>
<h2 id="h.3psdcrdzxe2n" class="c15 translated"><span class="c45 c47">创建我们自己的插件，用地图框添加兴趣点搜索</span></h2>
<p class="c9 translated"><span class="c0">除了通过名称或城市名称搜索来找到特定的商店，用户还应该能够搜索给定的位置，然后找到该位置周围的所有商店。</span></p>
<p class="c9 translated">最好的方法是地理编码服务。这里，我们将使用<span class="c5">地图框位置API </span> <span class="c0">。来自最终用户的每个新搜索都会触发对此API的新请求，返回位置名称及其纬度和经度信息。一旦用户选择了一个结果，我们可以使用lat/long属性来触发针对Algolia API的地理搜索，并检索该位置周围的商店。</span></p>
<p class="c9 translated">要创建你的自定义插件，你需要<span class="c3"> <a class="c22" href="https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/plugins/%23building-your-own-plugin">实现一个给定的接口</a> </span> <span class="c0">..</span></p>
<p class="c9 translated"><span class="c0">在我们的例子中，为了减少对Mapbox API的API调用次数，我们使用了一种去抖动策略:</span></p>
<ul class="c24 lst-kix_bu885xja2rne-0 start">
<li class="c1 c21 li-bullet-0 translated"><span class="c0">避免在每次击键时都发送API调用，但只在经过一段时间间隔后才发送，在我们的例子中是300毫秒。</span></li>
<li class="c1 c21 li-bullet-0 translated">基于一个<span class="c3"><a class="c22" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout"/></span><span class="c0">。首先，它将超时设置为作为参数传递的值。如果在超时结束前再次调用该函数，那么它将清除该函数，并以相同的持续时间再次设置它。</span></li>
</ul>
<h3 id="h.4zbffv4rfqt8" class="c46 translated"><span class="c36 c5">让我们构建Mapbox API请求</span></h3>
<p class="c9 translated"><span class="c0">在创建插件之前，我们想创建一段负责调用Mapbox API的代码。</span></p>
<pre class="lang:js decode:true ">const mapboxURL = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(&#13;
    query&#13;
  )}.json`;&#13;
  const requestParams = {&#13;
    ...options,&#13;
    types: options.types,&#13;
    country: options.country,&#13;
    access_token: process.env.REACT_APP_MAPBOX_TOKEN,&#13;
  };&#13;
  &#13;
  const endpoint = [&#13;
    mapboxURL,&#13;
    qs.stringify(requestParams, { arrayFormat: 'comma' }),&#13;
  ].join('?');&#13;
</pre>
<p class="c9 translated">注意:您可以在Mapbox docs 中找到请求<span class="c3">的所有可用参数。</span></p>
<h4 id="h.4wqjhfzdovn3" class="c46 translated">将结果作为源插件传递给Autocomplete</h4>
<p class="c9 translated">现在，我们需要将这个函数连接到我们的自动完成功能。这个想法是将结果传递给由<code>Autocomplete</code>等待的响应，并将其封装在一个函数中以便重用。</p>
<pre class="lang:js decode:true ">const createMapboxGeocodingPlugin = (&#13;
  options: IMapboxRequestParameters,&#13;
  HitComponent: React.ComponentType &lt; { item: IMapboxFeature; onClick: (item: IMapboxFeature) =&gt; void;&#13;
  } &gt; ,&#13;
  onClick: (result: IMapboxFeature) =&gt; void&#13;
) =&gt; {&#13;
  return {&#13;
    getSources({&#13;
      query&#13;
    }: {&#13;
      query: string&#13;
    }) {&#13;
      const mapboxURL = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(&#13;
        query&#13;
      )}.json`;&#13;
      const requestParams = {&#13;
        ...options,&#13;
        types: options.types,&#13;
        country: options.country,&#13;
        access_token: process.env.REACT_APP_MAPBOX_TOKEN,&#13;
      };&#13;
&#13;
      const endpoint = [&#13;
        mapboxURL,&#13;
        qs.stringify(requestParams, {&#13;
          arrayFormat: 'comma'&#13;
        }),&#13;
      ].join('?');&#13;
&#13;
      return debouncedFetch(endpoint)&#13;
        .then((response: any) =&gt; response.json())&#13;
        .then((data: IMapboxGeocodingResponse) =&gt; {&#13;
          return [{&#13;
            sourceId: 'mapboxPlugin',&#13;
            getItems() {&#13;
              return data.features;&#13;
            },&#13;
            templates: {&#13;
              header() {&#13;
                return 'Mapbox Places results'&#13;
              },&#13;
              item({&#13;
                item&#13;
              }: {&#13;
                item: IMapboxFeature&#13;
              }) {&#13;
                return ( &amp;&#13;
                  lt; HitComponent item = {&#13;
                    item&#13;
                  }&#13;
                  onClick = {&#13;
                    (item: IMapboxFeature) =&gt; onClick(item)&#13;
                  }&#13;
                  /&gt;&#13;
                );&#13;
              },&#13;
              noResults() {&#13;
                return 'No results.';&#13;
              },&#13;
            },&#13;
          }, ];&#13;
        });&#13;
    },&#13;
  };&#13;
};&#13;
</pre>
<p class="translated">这段代码将新插件添加到我们的<code>Autocomplete</code>实例中。</p>
<p class="translated">和以前一样，我们现在想将插件添加到我们的Autocomplete实例中。</p>
<pre class="lang:js decode:true ">const plugins = useMemo(() =&gt; {&#13;
  const mapboxGeocodingPlugin = createMapboxGeocodingPlugin({&#13;
      fuzzyMatch: true,&#13;
      autocomplete: true,&#13;
      types: ['country', 'place', 'poi'],&#13;
      country: ['FR', 'BE', 'GB', 'DE', 'CH', 'IT', 'ES'],&#13;
      access_token: process.env.REACT_APP_MAPBOX_TOKEN!,&#13;
    },&#13;
    MapboxAddressComponent,&#13;
    (item) =&gt; {&#13;
      setCurrentStoreCoordinates([item.geometry.coordinates[0], item.geometry.coordinates[1]])&#13;
    }&#13;
  );&#13;
&#13;
  const querySuggestionPlugin = createSuggestionsPlugin(&#13;
    searchClient,&#13;
    indexName as string,&#13;
    (query) =&gt; {&#13;
      setSearchState((searchState) =&gt; ({&#13;
        ...searchState,&#13;
        query: query,&#13;
      }));&#13;
    },&#13;
    (item) =&gt; setCurrentStoreCoordinates([item._geoloc.lng, item._geoloc.lat]),&#13;
    SuggestionComponent&#13;
  );&#13;
&#13;
  return [mapboxGeocodingPlugin, querySuggestionPlugin];&#13;
}, []);&#13;
</pre>
<p class="translated">注意:在我们的实现中，我们将结果限制在几个国家和几类地方，所以MapBox API返回最相关的结果。您可以根据需要调整这些变量。</p>
<pre class="lang:js decode:true ">types: ['country', 'place', 'poi'],&#13;
country: ['FR', 'BE', 'GB', 'DE', 'CH', 'IT', 'ES'],&#13;
</pre>
<p class="translated">一旦完成，我们现在可以检查我们的应用程序，看看地图框结果是否已经添加到我们的自动完成。让我们在搜索栏中键入“Marsel ”,看看我们是否能找到位于马赛-普罗旺斯机场外的商店…</p>
<p class="c9 translated"><img loading="lazy" class="alignnone size-large wp-image-12979" src="../Images/a9aed7aa000bf15f6aaecb93e03c811e.png" alt="Store Locator - Autocomplete preview" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image47-614x400.png 614w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image47-273x178.png 273w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image47-768x500.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image47-1536x1000.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image47.png 1999w" sizes="(max-width: 614px) 100vw, 614px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image47-614x400.png"/></p>
<p class="c9 translated">而且它似乎正在工作！万岁！ </p>
<h3 id="h.hadd0ppy11h0" class="c15 translated"><span class="c45 c47">将点击的信息传递给我们的即时搜索实例</span></h3>
<p class="c9 translated"><span class="c0">既然用户可以在Autocomplete下拉列表中选择一个结果，我们希望将信息传递给InstantSearch实例，这样我们就可以:</span></p>
<ul class="c24 lst-kix_i04vqsnc3bbd-0 start">
<li class="c1 c21 li-bullet-0 translated"><span class="c0">显示所选商店位置及其详细信息</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">使用所选位置的纬度和经度运行Algolia地理搜索，检索并显示离该位置最近的商店</span></li>
</ul>
<p class="c1 translated"><span class="c18 c5">因为我们将使用地理位置坐标，这个方法对两个插件都有效。</span></p>
<h3 class="c9 translated"><strong> <span class="c5">创建存储当前坐标的位置</span> </strong></h3>
<p class="c9 translated"><span class="c0">为了在自动完成中存储所选的地点/商店，让我们创建一个状态变量来存储这些数据，我们称之为<code>currentStoreCoordinates</code> </span></p>
<pre class="lang:js decode:true ">const [currentStoreCoordinates, setCurrentStoreCoordinates] = useState&lt; [number, number] | null &gt;(null);&#13;
</pre>
<h4 class="c9 translated"><strong> <span class="c18 c5">创建处理程序</span> </strong></h4>
<p class="c9 translated">接下来，让我们创建一个方法，它根据我们单击的元素更新这个存储。从<code>createSuggestionsPlugin</code>返回的条目将有一个带有<span class="c11"> <code>lat</code> </span>和<span class="c11"> <code>lng</code> </span> <span class="c0">键的<code>_geoloc</code>对象，它们本身来自存储在Algolia索引中的记录。</span></p>
<p class="c9 translated">由<code>createMapboxGeocodingPlugin</code>返回的项目将有一个<span class="c11">几何</span>对象，带有一个<span class="c11"> </span>坐标<span class="c11"> </span> <span class="c0">数组。</span></p>
<p class="c9 translated"><span class="c0">首先，让我们创建一个方法来处理对建议的点击:</span></p>
<pre class="lang:js decode:true ">const handleClickOnSuggestion = (hit: Hit) =&gt; {&#13;
  const { lat, lng } = hit._geoloc;&#13;
  const coordinates: [number, number] = [lng, lat];&#13;
  setCurrentStoreCoordinates(coordinates);&#13;
  setCurrentStoreName(hit.name)&#13;
  setIsOpen(true)&#13;
};&#13;
</pre>
<p class="translated">将它作为<code>onClick</code>处理程序添加到<code>querySuggestionPlugin</code>实例中。</p>
<p class="translated">现在，让我们更新地图框插件的<code>onClick</code>处理程序:</p>
<pre class="lang:js decode:true ">(item) =&gt; setCurrentStoreCoordinates([item.geometry.coordinates[0], item.geometry.coordinates[1]])&#13;
</pre>
<h4 class="translated"><strong>将纬度和经度传递给即时搜索和我们的组件</strong></h4>
<p class="translated">在第2部分，我们配置了我们的<code>&lt;InstantSearch/&gt;</code>包装器:</p>
<pre class="lang:js decode:true">&lt;Configure aroundLatLngViaIP={true} /&gt;&#13;
</pre>
<p class="translated">现在，我们将利用<code>aroundLatLng</code>属性来触发基于纬度和经度参数的地理搜索。</p>
<pre class="lang:js decode:true ">&amp;lft;Configure&#13;
    aroundLatLngViaIP={!currentStoreCoordinates?.length}&#13;
    aroundLatLng={!!currentStoreCoordinates?.length ? '' : currentStoreCoordinates?.join(',')} /&gt;&#13;
</pre>
<p class="c9 translated">这一次，我们将<span class="c6"> <code>aroundLatLngViaIP</code> </span>设置为<span class="c6">真</span>或<span class="c6">假</span>，这取决于<span class="c27"> <code><code>currentStoreCoordinates</code> </code> </span>的状态。如果<code>currentStoreCoordinates</code>为空，我们将<span class="c6"> <code>aroundLatLngViaIP</code> </span>设置为<span class="c6"> true </span>并基于用户的IP地址执行地理搜索，否则我们将坐标作为字符串传递给<span class="c27"> <code>aroundLatLng</code> </span>以使用这些坐标执行地理搜索<span class="c0">！仅此而已！</span></p>
<p class="c9 translated">现在，让我们将<span class="c27"> <code>currentStore={currentStoreCoordinates}</code> </span>添加到我们的<code>StoreComponent</code>中，并添加到地图中以突出显示所选的商店。</p>
<p class="c9 translated">至此，我们已经完成了自动完成部分！我们现在有一个全功能的商店定位器，它允许用户找到商店:</p>
<ul class="c24 lst-kix_xrllsofkkqye-0 start">
<li class="c1 c21 li-bullet-0 translated"><span class="c0">他们当前的位置附近，由于他们的IP地址和从页面加载</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">基于当前的<code>viewport</code>，每次地图移动或放大或缩小时都会更新</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">通过自动完成功能使用关键字搜索，根据商店名称或城市名称搜索商店</span></li>
<li class="c1 c21 li-bullet-0 translated">通过自动完成功能使用关键字搜索<span class="c0">，搜索一个地点名称并查找附近的所有商店</span></li>
</ul>
<h2 class="translated"><a id="adding-the-twilio-sms-experience" class="anchor" href="#adding-the-twilio-sms-experience" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>添加Twilio短信体验</h2>
<h3 id="h.fi06uleeuasz" class="c15 translated"><span class="c45 c47">什么是Twilio？</span></h3>
<p class="c9 translated"><span class="c0"> Twilio是领先的CPaaS(通信平台即服务)公司，由Jeff Lawson于2008年在旧金山创立。像Deliveroo、优步、亚马逊GetAround这样的公司都是客户，所以你很可能在不知情的情况下使用了Twilio的服务。</span></p>
<p class="c9 translated"><span class="c0">他们为许多通信渠道提供服务，从短信、语音通话和推送通知，一直到完全可配置的企业呼叫中心。他们还通过收购SendGrid和Segment扩展到电子邮件和客户分析领域。</span></p>
<p class="c9 translated"><span class="c0">在这个项目中，我们将使用SMS，原因有三:</span></p>
<ul class="c24 lst-kix_p7djsdbkpvwp-0 start">
<li class="c1 c21 li-bullet-0 translated"><span class="c0"> BOPIS功能(在线购买，店内提货)通过短信接收店铺位置</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">缺货通知，因此只要产品有货，您就会收到一条短信</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">营销通知</span></li>
</ul>
<h3 id="h.yxpacgf629k1" class="c15 translated">创建您的帐户</h3>
<p class="c9 translated"><span class="c0">让我们创建自己的账户，并获取账户SID和认证令牌。</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12980" src="../Images/d382bb1e0bf77745bc4b3a8e2e82fbae.png" alt="Twilio.com homepage" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image12-617x400.png 617w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image12-275x178.png 275w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image12-768x498.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image12-1536x995.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image12.png 1999w" sizes="(max-width: 617px) 100vw, 617px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image12-617x400.png"/></p>
<p class="c9 translated"><span class="c0">到<a href="https://www.twilio.com/">Twilio.com</a>点击<a href="https://www.twilio.com/try-twilio">报名</a>。输入创建免费Twilio帐户所需的信息。</span></p>
<p class="c9 translated">一旦你登录，你将登陆“控制台”，在那里你会找到两条关键信息:你的Twilio账户SID和Auth Token。</p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12981" src="../Images/e829afb7d204e91cc9dae5c694aa563c.png" alt="Twilio Dashboard - Account info" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image32-617x400.png 617w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image32-275x178.png 275w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image32-768x498.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image32-1536x995.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image32.png 1999w" sizes="(max-width: 617px) 100vw, 617px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image32-617x400.png"/></p>
<p class="c9 translated">我们将使用他们的无服务器功能(<strong> <span class="c5">功能</span> </strong> <span class="c0">)，而不是我们自己的后端。如果有一天你需要从你的服务器发送API请求到Twilio，你知道在哪里可以找到它！</span></p>
<h3 id="h.51cy6j4yn1ta" class="c15 translated"><span class="c45 c47">获得您的第一个电话号码并创建您的第一个短信请求</span></h3>
<p class="c9 translated">要发送短信(尤其是在美国和加拿大)，您需要购买一个专用电话号码，对于其他国家，您可以在Twilio网站<span class="c0"/>上查看<a href="https://www.twilio.com/guidelines/regulatory"> Twilio的监管指南</a></p>
<p class="c9 translated">如果您想在法国发送手机短信，可以跳过这一步，因为购买一个法国电话号码很麻烦。这不是Twilio的错，而是ARCEP <em> ( </em>  <em> <span class="c11 c73">)规则的后果。</span> </em> <span class="c63 c59 c67">你可以去“创建你的第一个短信服务”。对于法国，我们将使用阿尔法发送器。，它将您的品牌标识为发送者—这是法国法律的要求。</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12982" src="../Images/97b7125d6c0e0b702269ffae9433b1a7.png" alt="Twilio SMS preview" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image27-568x400.jpg 568w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image27-253x178.jpg 253w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image27-768x541.jpg 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image27.jpg 1284w" sizes="(max-width: 568px) 100vw, 568px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image27-568x400.jpg"/></p>
<p class="c9 translated">如需购买电话号码，请前往左侧栏，进入<strong> <span class="c18 c5">电话号码&gt;管理&gt;购买电话号码</span> </strong></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12983" src="../Images/d4456855e906dbd46fba0bdbf745b939.png" alt="Twilio Dashboard - Sidebar" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image6-188x400.png 188w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image6-84x178.png 84w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image6.png 646w" sizes="(max-width: 188px) 100vw, 188px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image6-188x400.png"/></p>
<p class="c9 translated"><span class="c0">接下来，选择您想要购买电话号码的国家，然后点击购买。</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12984" src="../Images/14e177e4d798665109b024b38749a7cb.png" alt="Twilio Dashboard - Buy Number" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image40-720x274.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image40-320x122.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image40-768x292.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image40-1536x584.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image40.png 1999w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image40-720x274.png"/></p>
<p class="c9 translated"><span class="c0">确认后，您现在自豪地拥有了一个新的电话号码！</span></p>
<h3 id="h.5jut1htck2o" class="c15 translated"><span class="c47 c52">创建您的第一个信息服务</span></h3>
<p class="c9 translated"><span class="c0">设置新的电话号码(如果您在法国，则为Alpha发送者)后，在搜索栏中输入“信息服务”，然后输入“信息服务”(您可以体验另一种自动完成功能)。</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12985" src="../Images/14c3ecc62e4fbec01e5a791165c6d154.png" alt="Twilio Dashboard - Dropdown selection" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image28-720x290.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image28-320x129.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image28-768x310.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image28.png 942w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image28-720x290.png"/></p>
<ul>
<li class="c9 translated">从建议列表中选择<strong> <span class="c5">创建消息服务</span> </strong></li>
<li class="c9 translated">将您的新消息服务命名为，例如，<strong> <span class="c5">存储定位器</span> </strong>并选择<strong> <span class="c5">通知我的用户</span> <span class="c0">。</span>T24】</strong></li>
<li class="c9 translated">接下来，点击<strong> <span class="c5">添加发件人</span> </strong>，然后点击<span class="c5"> <strong>阿尔法发件人</strong> </span> <span class="c0">，输入您的企业名称。</span></li>
<li class="c9 translated">如果您购买了电话号码，您可以从列表中选择您的电话号码。</li>
</ul>
<p class="c9 translated"><span class="c0">最后，您的消息服务应该类似于下面的截图</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12986" src="../Images/8a5c4404b970616cedf23147bd2a4b9c.png" alt="Twilio Dashboard - sender pool" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image19-720x296.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image19-320x131.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image19-768x315.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image19-1536x631.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image19.png 1999w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image19-720x296.png"/></p>
<p class="c9 translated">现在，进入<strong> <span class="c5">属性</span> </strong> <span class="c0">，复制你的消息服务SID。</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12987" src="../Images/7dc27aafa9e54218ca5b671e26c727a2.png" alt="Twilio Dashboard - Messaging service settings" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image36-720x285.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image36-320x126.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image36-768x304.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image36-1536x607.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image36.png 1999w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image36-720x285.png"/></p>
<h3 id="h.ms43kkog5isn" class="c15 translated"><span class="c45 c47">创建发送短信的功能</span></h3>
<p class="c9 translated">使用消息SID，导航到功能(您可以搜索它或在<strong> <span class="c5">浏览产品</span> <span class="c5"> &gt;开发人员工具&gt;功能</span> </strong> <span class="c5"> ) </span> <span class="c0">下找到它)。</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12988" src="../Images/4a69481459a68dac524c9eaa7fa1670f.png" alt="Twilio Dashboard - explore products" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image44-617x400.png 617w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image44-275x178.png 275w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image44-768x498.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image44-1536x995.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image44.png 1999w" sizes="(max-width: 617px) 100vw, 617px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image44-617x400.png"/></p>
<p class="c9 translated">再次创建一个服务，给它命名，点击<strong> <span class="c5">下一个</span> </strong> <span class="c0">。浏览器中将打开一个IDE。</span></p>
<p class="c9 translated">点击<strong> <span class="c19 c5"> +添加</span> &gt; </strong> <span class="c5"> <strong>新建功能</strong> </span>创建一个新功能，命名为“下单”。将<span class="c0">的可见性设置为“public ”,因为我们需要在Twilio之外调用它。</span></p>
<p class="c9 translated">现在，转到<strong> <span class="c5">依赖项</span> </strong>并添加<span class="c5"> <code>date-fns</code> </span>包来处理日期。</p>
<p class="translated"><img loading="lazy" class="alignnone size-full wp-image-12989" src="../Images/119fd4d3d6d315b5309334a8ad0c4828.png" alt="Twilio Misc - dependency label" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image14.png 326w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image14-320x61.png 320w" sizes="(max-width: 326px) 100vw, 326px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image14.png"/></p>
<p class="c9 translated">在模块字段中，键入<span class="c6"> <code>date-fns</code> </span> <span class="c0">，然后单击添加。</span></p>
<p class="c9 translated"><span class="c0">现在，让我们添加负责发送消息的代码:</span></p>
<pre class="lang:js decode:true">// Let's require date-fns functions, we'll use them to manipulate dates.&#13;
const parse = require('date-fns/parse');&#13;
const format = require('date-fns/format');&#13;
exports.handler = async function(context, event, callback) {&#13;
&#13;
  // Let's fix CORS, this is required because we are calling this function from outside the twil.io domain&#13;
  const response = new Twilio.Response();&#13;
  response.appendHeader('Access-Control-Allow-Origin', 'https://localhost:3000'); // Change this by you domain&#13;
  response.appendHeader('Access-Control-Allow-Methods', 'GET, OPTIONS, PUT, POST, DELETE');&#13;
  response.appendHeader('Access-Control-Allow-Headers', 'Content-Type');&#13;
&#13;
  // Now we're grabbing data from the request payload&#13;
  const {&#13;
    store,&#13;
    customer,&#13;
    time,&#13;
    phoneNumber&#13;
  } = event;&#13;
&#13;
  // We're using format to display a nice date in the SMS&#13;
  const formattedDate = format(parse(time, 'dd-MM-yyyy::HH:mm', new Date()), "eee, d LLLL yyyy 'at' kk:mm");&#13;
&#13;
  // Let's write the message&#13;
  const message = `Hey ${customer}. Your order will be ready to pick-up at ${store} on ${formattedDate}. Thanks for beeing a Spencer &amp; William Customer`;&#13;
&#13;
  // Time to hit the send button !&#13;
  const client = context.getTwilioClient();&#13;
  await client.messages.create({&#13;
    body: message,&#13;
    messagingServiceSid: 'MG9378a33499ec5b0201374e6e8b0adb67',&#13;
    to: phoneNumber&#13;
  })&#13;
&#13;
  // Don't forget the callback otherwise you'd raise an error as the function will keep running&#13;
  return callback(null, response)&#13;
&#13;
};&#13;
</pre>
<p class="c9 translated">仅此而已！点击<strong> <span class="c5">保存</span></strong><strong><span class="c5">部署所有</span> </strong> <span class="c0">，大概需要2分钟左右，你的函数名旁边会出现一个绿色的复选标记。现在可以从外部使用我们的Twilio凭证调用Twilio API来使用这个函数。</span></p>
<p class="c9 translated">注意:y <span class="c0">你可以使用一个API explorer来测试它，比如Postman或者Paw.cloud(在macOS上)</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12990" src="../Images/c57f76cf34e081da31e8d6a5436c00d0.png" alt="Twilio Dashboard - Deploy function" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image22-518x400.png 518w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image22-230x178.png 230w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image22-768x593.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image22-1536x1186.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image22.png 1999w" sizes="(max-width: 518px) 100vw, 518px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image22-518x400.png"/></p>
<h3 id="h.iekxdm18mbso" class="c15 translated"><span class="c45 c47">从你的代码</span>中调用下单函数</h3>
<p class="c9 translated">您将在<span class="c6">组件/ </span> <span class="c0">目录中找到表单组件。当您从列表或地图上选择商店时，它会出现在屏幕上。</span></p>
<p class="c9 translated"><span class="c0">它有三个字段:客户名称、提货日期和电话号码。现在，我们需要在单击“Place Order”按钮时执行请求。</span></p>
<p class="c9 translated"><span class="c0">我们将使用axios来执行请求，但您也可以使用自己喜欢的库。</span></p>
<pre class="lang:sh decode:true ">yarn add axios&#13;
</pre>
<p class="c9 translated">让我们填充<span class="c27"> <code>sendRequest()</code> </span> <span class="c0">方法:</span></p>
<pre class="lang:js decode:true ">async sendRequest() {&#13;
&#13;
  const {&#13;
    customer,&#13;
    time,&#13;
    phoneNumber,&#13;
    phoneCountry&#13;
  } = this.state&#13;
  const {&#13;
    store&#13;
  } = this.props&#13;
&#13;
  this.setState({&#13;
    isLoading: true&#13;
  });&#13;
  await axios.post(process.env.REACT_APP_TWILIO_FUNCTION_URL as string, {&#13;
    store,&#13;
    customer,&#13;
    time,&#13;
    phoneNumber: parsePhoneNumber(phoneNumber, phoneCountry).number&#13;
  });&#13;
  this.setState({&#13;
    isLoading: false&#13;
  });&#13;
}&#13;
</pre>
<p class="c9 translated">仅此而已，你的应用程序现在将向你的客户发送短信。这是我们为这个应用程序编写的最后几行代码，现在是时候将它部署到智能云上了！</p>
<h2 id="h.rmvfj0frawz" class="c9 c50 translated">在智能云上部署您的应用</h2>
<p class="c9 translated">最后一步，我们将把商店定位器部署到<span class="c3"> <a class="c22" href="%22https://www.clever-cloud.com/en">智能云</a> </span> <span class="c0">托管平台，这样你就可以向你的朋友和同事展示你新开发的应用。</span></p>
<p class="c9 translated">转到您的智能云仪表盘，点击<strong> <span class="c5"> +创建</span> / <span class="c5">一个应用</span> <span class="c0"> </span> </strong></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12992" src="../Images/a84f760b0c043289f2b91ee9effb6c2c.png" alt="CleverCloud Dashboard - overview" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image16-427x400.png 427w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image16-190x178.png 190w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image16-768x720.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image16-1536x1440.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image16.png 1999w" sizes="(max-width: 427px) 100vw, 427px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image16-427x400.png"/></p>
<p class="translated">选择<strong> <span class="c5">创建新应用</span> <span class="c0"> : </span> </strong></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12993" src="../Images/384d177e80e2ab265cbe1d9d1f0240fe.png" alt="CleverCloud Dashboard - create new app" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image54-598x400.png 598w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image54-266x178.png 266w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image54-768x514.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image54-1536x1027.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image54.png 1999w" sizes="(max-width: 598px) 100vw, 598px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image54-598x400.png"/></p>
<p class="c9 translated">选择应用类型:<strong> <span class="c5">节点</span> </strong>。点击<strong> <span class="c5">继续下一步</span> </strong></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12995" src="../Images/62daa0b3d31b697fbd7250c04011799c.png" alt="CleverCloud - add node dialog" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image53-720x161.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image53-320x72.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image53-768x172.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image53-1536x344.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image53.png 1999w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image53-720x161.png"/></p>
<p class="c9 translated"><span class="c0">为您的应用命名，并选择您的数据中心。</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12996" src="../Images/d2c7d6c9d834779ee78644c76c2885f4.png" alt="CleverCloud Dashboard - Pick server location" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image34-653x400.png 653w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image34-290x178.png 290w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image34-768x471.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image34-1536x941.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image34.png 1999w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image34-653x400.png"/></p>
<p class="c9 translated">最后，选择<strong> <span class="c5">配置提供者</span> </strong>。这将替换我们的<span class="c6"> .local.env </span>文件，并在构建时在我们的应用程序中注入变量。然后点击<strong> <span class="c5">下一个</span> </strong> <span class="c0">并给你的配置提供者起一个名字。</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12997" src="../Images/e18a1c81878a19313ea18e8a657f37bc.png" alt="CleverCloud Dashboard - Add Add-on" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image9-697x400.png 697w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image9-310x178.png 310w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image9-768x441.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image9-1536x881.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image9.png 1999w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image9-697x400.png"/></p>
<p class="c9 translated">在下一个屏幕上，点击<span class="c5"> <strong>专家</strong> </span> <span class="c0">并复制/粘贴您的<code>.local.env</code>文件。</span></p>
<p class="c9 translated"><span class="c0">将这两行添加到环境变量中，以使用yarn并在安装完依赖项后构建项目:</span></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12998" src="../Images/92c90c99550b1f318d31288a45e0d554.png" alt="CleverCloud Dashboard - Env variable setup" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image46-720x294.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image46-320x131.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image46-768x314.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image46-1536x628.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image46.png 1999w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image46-720x294.png"/></p>
<pre class="lang:sh decode:true ">CC_POST_BUILD_HOOK="yarn build"&#13;
NODE_BUILD_TOOL="yarn"&#13;
</pre>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-12999" src="../Images/2fc7143acf5b5fe87cda5ce749ff2dfb.png" alt="CleverCloud Dashboard - Env variable setup edit" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image48-720x377.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image48-320x167.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image48-768x402.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image48-1536x804.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image48.png 1999w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image48-720x377.png"/></p>
<p class="c9 translated"><span class="c0">点击绿色按钮两次，点击左侧菜单中的节点机。</span>按照屏幕上方的步骤，将Clever的git URL添加到您的项目中，并推送它！使用<em> <span class="c58 c59 c11 c78">“域名”下的网址，3到4分钟后就可以使用了。</span> </em></p>
<p class="translated"><img loading="lazy" class="alignnone size-large wp-image-13000" src="../Images/9b547fc56be604ad54a4693a404bdef5.png" alt="CleverCloud Dashboard - App infos" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/image15-720x216.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image15-320x96.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image15-768x230.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image15-1536x460.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/image15.png 1999w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/image15-720x216.png"/></p>
<h2 id="h.lhuqciex7di7" class="c9 c50 translated"><span class="c40">包装</span></h2>
<p class="c9 translated"><span class="c0">总结一下我们本周的成就:</span></p>
<ul class="c24 lst-kix_e3mry2qfhz35-0 start">
<li class="c1 c21 li-bullet-0 translated"><span class="c0">我们增加了一个自动完成下拉菜单，补充了现有的应用程序体验，允许用户按名称或位置名称搜索商店，这样他们就可以找到该位置附近最近的商店。</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">我们增加了Twilio支持，可以向客户发送短信。</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">我们已经在智能云上部署了我们的应用。🎊</span></li>
</ul>
<p class="c9 translated"><span class="c0">这就是我们关于使用Algolia、Mapbox和Twilio构建商店定位器的系列报道。但是你还可以添加更多的功能:</span></p>
<ul class="c24 lst-kix_tlx2vl8thbws-0 start">
<li class="c1 c21 li-bullet-0 translated"><span class="c0">利用商店定位器提供BOPIS特色</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">使用Twilio SendGrid发送电子邮件而不是短信</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">使用Twilio段跟踪和更新点击次数最多的商店</span></li>
<li class="c1 c21 li-bullet-0 translated"><span class="c0">使用Stripe APIs添加支付选项</span></li>
</ul>
<p class="c9 translated">我希望你喜欢这个系列！套用一位我非常钦佩的首席执行官兼开发人员的话:<span class="c58 c5 c11 c59">我迫不及待地想看看你会开发什么。</span></p>
</div></div>    
</body>
</html>