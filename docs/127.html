<html>
<head>
<title>Algolia + MongoDB – Part 2: Proposed solution and design | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Algolia+MongoDB–第2部分:建议的解决方案和设计</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/supercharging-search-for-ecommerce-solutions-with-algolia-and-mongodb-proposed-solution-and-design/#0001-01-01">https://www.algolia.com/blog/engineering/supercharging-search-for-ecommerce-solutions-with-algolia-and-mongodb-proposed-solution-and-design/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="translated">我们邀请Starschema的朋友写一个结合使用Algolia和MongoDB的例子。我们希望您喜欢这个由全栈工程师Soma Osvay撰写的四部分系列。</p>
<p class="translated">如果你想回顾或跳过，以下是其他链接:</p>
<p class="translated"><a href="https://www.algolia.com/blog/engineering/supercharging-search-for-ecommerce-solutions-with-algolia-and-mongodb-use-case-architecture-and-current-challenges/">第1部分——用例、架构和当前挑战</a></p>
<p class="translated"><a href="https://www.algolia.com/blog/engineering/supercharging-search-for-ecommerce-solutions-with-algolia-and-mongodb-data-pipeline-implementation/">第三部分——数据管道实施</a></p>
<p class="translated"><a href="https://www.algolia.com/blog/engineering/supercharging-search-for-ecommerce-solutions-with-algolia-and-mongodb-frontend-implementation-and-conclusion/">第4部分-前端实施和结论</a></p>
<hr/>
<p class="translated">当我们讨论将第三方索引系统集成到产品中的挑战时，我们的工程师立即提出了三个潜在的问题:</p>
<ul>
<li class="translated">我们如何跨多个数据提供者维护数据完整性和数据就绪性？</li>
<li class="translated">我们如何确保我们的应用程序的性能不会因为引入第三方系统而受到影响？</li>
<li class="translated">我们如何在第三方系统上维护现有的安全和访问控制规则？</li>
</ul>
<p class="translated">到目前为止，我们有一个<strong>真实的单一来源</strong>数据库(清单数据库),其中存储了所有的清单。当将Algolia引入生态系统时，我们必须优先保证它与数据库保持同步。这些系统之间的任何不一致都会对我们站点的UX产生严重影响。我们不希望最终出现搜索结果:</p>
<ul>
<li class="translated">单击时抛出404未找到错误</li>
<li class="translated">列表本身不是最新的(即搜索结果包含不同的标题、描述等)</li>
<li class="translated">不会出现在现有的房地产列表中</li>
</ul>
<p class="translated">所有这些情况都会导致<strong>对我们的服务</strong>失去信心，并可直接转化为<strong>收入损失</strong>。这是绝对必要的，我们都创建一个我们现有的数据集到Algolia的初始加载，并保持Algolia与该数据集中所有未来的变化保持同步。</p>
<p class="translated">我们的后端应用程序已经负荷过重。它使用Kubernetes进行水平扩展，但是我们希望避免由于服务器上的高流量而大幅增加运营成本。设计解决方案时，我们必须将尽可能多的流量转移到Algolia。</p>
<p class="translated">我们还想确保我们不会损害应用程序的安全性和访问控制。目前，我们的应用程序不需要登录会话来查询列表，所以这并不重要，但如果有人登录了，那么能够使用Algolia存储用户的身份就很好了，这样就可以使用它来个性化搜索结果并完善我们的内部报告。</p>
<h2 class="translated"><a id="design-possibilities" class="anchor" href="#design-possibilities" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>设计可能性</h2>
<p class="translated">我们可以将其分解为三项任务:</p>
<ol>
<li class="translated">在Algolia中索引我们现有的所有列表数据。为此，我们将在Jupyter笔记本中创建一个Python脚本来开发数据加载逻辑。我们以后可以重用其中的一部分。如果你想知道我为什么在这里选择Jupyter笔记本，那是因为它允许快速迭代、部分执行和简单的评论系统。这在构建原型和进行代码评审时很有帮助。我将在本系列的第三篇文章中实现它。</li>
<li class="translated"><a href="https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/in-depth/the-different-synchronization-strategies/">定期更新Algolia指数</a>任何列表变化。</li>
<li class="translated">创建直接从前端搜索Algolia的能力，这样我们就不需要接触任何遗留的后端代码。</li>
</ol>
<p class="translated">更新后的架构图如下所示:</p>
<p class="translated"><img loading="lazy" class="alignnone size-full wp-image-15599" src="../Images/fb802cafe901bd8d9e61ae50b5607cfc.png" alt="Diagram of the new architecture" srcset="https://blog-api.algolia.com/wp-content/uploads/2022/07/new-architecture-mongodbalgolia-series.png 1150w, https://blog-api.algolia.com/wp-content/uploads/2022/07/new-architecture-mongodbalgolia-series-178x178.png 178w, https://blog-api.algolia.com/wp-content/uploads/2022/07/new-architecture-mongodbalgolia-series-399x400.png 399w, https://blog-api.algolia.com/wp-content/uploads/2022/07/new-architecture-mongodbalgolia-series-150x150.png 150w, https://blog-api.algolia.com/wp-content/uploads/2022/07/new-architecture-mongodbalgolia-series-768x770.png 768w" sizes="(max-width: 1150px) 100vw, 1150px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2022/07/new-architecture-mongodbalgolia-series.png"/></p>
<p class="translated">让我们来看看在任务2中我们可以采取的不同途径的一些优点和缺点。以下是我们的一些选择:</p>
<ul>
<li class="translated"><strong>一个</strong>。创建更多的Python脚本，作为我们现有ETL过程的一部分运行(已经将数据同步到Mongo中)。这可能是一个好的选择，因为Algolia索引与MongoDB数据同时更新，使它们保持同步。此外，它在我现有的ETL过程中作为一个单独的任务运行，因此它可以很容易地被监控和维护。另一方面，如果数据库加载任务成功，而Algolia任务失败，那么我们的数据集之间就会出现一些不一致。这可能需要手动校正，这给我们的团队带来了很大的负担。</li>
<li class="translated"><strong> b </strong>。创建Python脚本，独立于我们的其他ETL工作流，将数据从Mongo同步到Algolia。这让我们可以独立地维护和监控Algolia，因为它会定期刷新基于Mongo数据库的数据。这可能会给数据平台团队带来额外的压力，因为它必须单独托管和维护。</li>
<li class="translated"><strong> c </strong>。使用<a href="https://www.mongodb.com/docs/atlas/app-services/triggers/overview/"> MongoDB触发器</a>。这里的想法是，当在MongoDB中添加、删除或编辑记录时，它将通过数据库触发器触发调用Algolia REST API的函数，直接同步到Algolia。这将根据在MongoDB中完成的操作自动更新我们的索引，而无需实现第三方解决方案。不过这个计划也不是没有缺点。MongoDB操作可能需要很长时间来执行，因此性能可能会成为一个问题。触发器也可能失败，因此我们仍然必须在MongoDB接口中手动监控它们。</li>
</ul>
<p class="translated">无论我们最终选择哪个选项，我们都将在本系列的第三篇文章中实现它。</p>
<p class="translated">最后，第四部分将着重于创建一个小型的基于web的前端来查询Algolia索引。我希望能够向我们的前端开发人员展示一个带有基本代码的工作解决方案，以便他们可以评估将其集成到我们现有的前端应用程序中所需的时间和精力。</p>
<h2 class="translated"><a id="dataset-technologies-used-for-implementation" class="anchor" href="#dataset-technologies-used-for-implementation" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>数据集&amp;用于实现的技术</h2>
<p class="translated">为了保持实现简单，我将使用一个对MongoDB公开可用的数据集，它与我的生产数据相似。这背后有多种原因:</p>
<ul>
<li class="translated">我希望我的脚本足够通用，将来可以用于我们的多个应用程序。从一开始就将它构建到脚本中的最佳方式是为我的最终数据集之外的东西设计和开发脚本。通过这种方式，我可以通过稍后对我的生产数据运行脚本来测试脚本的适应性。</li>
<li class="translated">我们也对这里的社区反馈感兴趣！我使用的是公共数据集，所以你可以尝试一下，告诉我们你的经历。</li>
<li class="translated">我们的MongoDB实例和所有ETL都在VPN后面，我坐在家里。由于我们的VPN很慢，我不希望在将数据从Mongo转移到Algolia时加载时间给我不切实际的性能计数器。</li>
</ul>
<p class="translated">我决定使用MongoDB的官方<a href="https://www.mongodb.com/docs/atlas/sample-data/sample-airbnb/">样本AirBnB列表数据集</a>，因为它相当接近我们现有的数据结构。我还将使用<a href="https://www.mongodb.com/atlas/database"> MongoDB Atlas </a>来托管我的样本数据库以及一个免费的Algolia帐户来存储记录。我可能已经是Python方面的专家了(这就是我们使用Jupyter笔记本的原因)，但我不熟悉HTML、CSS和JavaScript的前端语言，所以这将是一个测试Algolia的SDK是否像它们被认为的那样简单的好机会。</p>
<p class="translated"><a class="aligncenter" href="https://www.algolia.com/developers/code-exchange/backend-tools/integrate-mongo-db-with-algolia/"> <img loading="lazy" class="wp-image-13777" src="../Images/7665551c18b687f25dcadc15cb213b7d.png" alt="" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2022/01/CodeX@2x.png"/> </a></p>
<p class="translated">在本系列的第一篇文章中，我谈到了我们的用例、架构和我们面临的搜索挑战。</p>
<p class="translated">在本系列的第三篇文章中，我将实现数据摄取到Algolia中，并弄清楚如何保持数据最新。</p>
<p class="translated">在本系列的第四篇文章<a href="https://www.algolia.com/blog/engineering/supercharging-search-for-ecommerce-solutions-with-algolia-and-mongodb-frontend-implementation-and-conclusion/">中，我将实现一个示例前端，这样我们就可以从用户的角度评估产品，如果开发人员选择这个选项，就可以给他们一个先发制人的机会。</a></p>
</div></div>    
</body>
</html>