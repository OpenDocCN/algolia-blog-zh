<html>
<head>
<title>Building a Store Locator in React using Algolia, Mapbox, and Twilio – Part 2 | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Algolia、Mapbox和Twilio在React中构建商店定位器——第2部分</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-2/#0001-01-01">https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-2/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="c9 translated">这是我们关于构建商店定位器的3部分实时编码系列的第二篇文章。请务必查看<span class="c3"> <a class="c22" href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-1/">构建商店定位器-第1部分</a> </span>和<span class="c3"> <a class="c22" href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-3/">构建商店定位器-第3部分</a> </span>。</p>
<p class="c31 c41 c21 translated"><span class="c0">如今，电子商务购物者期望便利，希望现实世界和网络世界融合，允许他们通过任何渠道开展业务。这就是商店定位器的用途，这样用户就可以:</span></p>
<ul>
<li class="translated">在线搜索产品，然后在店内购买</li>
<li class="translated">亲自浏览和比较产品，然后在线购买</li>
<li class="translated">在线购物和购买产品，然后亲自提货</li>
<li class="translated">亲自退还之前购买的物品，而不是将它们寄回</li>
</ul>
<p class="translated">尽管如此，我们观察到太多的网站没有为用户提供一种优雅的方式来找到他们的“最近的商店”，无论是在线测试或购买，还是在线购买。</p>
<p class="translated">构建商店定位器似乎很复杂，因为它需要实现地理搜索、地址/兴趣点(POI)搜索，并在地图上显示结果。为了让每个人都尽可能容易地跟上，我们决定在三篇博客文章之后进行一系列的三次现场编码会议。在这些事件中，我们决定在React 中创建一个响应式<i>商店定位器，使用:</i></p>
<ul>
<li class="translated"><a href="https://www.algolia.com/"> Algolia </a>的地理搜索功能；</li>
<li class="translated"><a href="https://www.mapbox.com/use-cases/store-locator">地图框</a>用于显示地图和搜索位置和兴趣点</li>
<li class="translated"><a href="https://www.twilio.com/sms"> Twilio </a>用于在订单准备就绪后发送文本</li>
<li class="translated"><a href="https://www.clever-cloud.com/en/">颖云</a>主持</li>
</ul>
<p class="translated">使用React v17、<a href="https://www.algolia.com/doc/guides/building-search-ui/what-is-instantsearch/react/"> React InstantSearch </a>和<a href="https://github.com/algolia/autocomplete"> Autocomplete </a> UI库包装一切，在很短的时间内构建现代搜索和发现体验。</p>
<p class="translated"><iframe src="https://www.youtube.com/embed/jyntg6hkKMs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen">视频</iframe></p>
<p class="translated">注意:在第1部分中，我们创建了所有必需的帐户(Clever cloud和Algolia)，我们索引了数据，并配置了Algolia索引。<a href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-1/">阅读第1部分</a></p>
<h1 class="translated"><a id="adding-geo-search-capabilities" class="anchor" href="#adding-geo-search-capabilities" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>添加地理搜索功能</h1>
<p class="translated">为了快速找到距离我们当前位置或给定地址输入最近的商店，我们将利用<a href="https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/geo-search/react/"> Algolia地理搜索功能</a>，以及<a href="https://www.algolia.com/doc/guides/building-search-ui/what-is-instantsearch/react/"> React InstantSearch </a>，在列表视图和地图视图上显示找到的商店(使用Mapbox GL)。</p>
<p class="translated"><span>注</span>:你可以在项目的<a href="https://github.com/algolia-samples/store-locator-with-algolia-mapbox-twilio/tree/session-2-adding-instant-search-start"> Github资源库</a>中找到第1部分末尾获得的代码。</p>
<h2 class="translated"><a id="a-quick-overview-of-algolia%e2%80%99s-instantsearch" class="anchor" href="#a-quick-overview-of-algolia%e2%80%99s-instantsearch" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Algolia的即时搜索快速概述</h2>
<p class="translated">React InstantSearch是React的一个开源、生产就绪的UI库(也有VanillaJS、Vue、Angular、Swift和Kotlin版本)，它允许您在前端应用程序中快速构建搜索界面。</p>
<p class="translated">它的目标是通过提供一个<a href="https://www.algolia.com/doc/guides/getting-started/how-algolia-works/#the-full-ecosystem">完整的搜索生态系统</a>来帮助你尽可能顺利地实现令人敬畏的搜索体验。InstantSearch通过提供称为“小部件”的前端UI组件解决了这一巨大目标的重要部分，您可以将这些组件组装到独特的搜索界面中，例如:</p>

<p class="translated">在我们的例子中，我们将利用一些现有的小部件，如<a href="https://www.algolia.com/doc/api-reference/widgets/infinite-hits/react/">infini hits</a>和<a href="https://www.algolia.com/doc/api-reference/widgets/refinement-list/react/"> RefinementList </a>，我们将构建一个定制的小部件，以便在Mapbox支持的地图上显示结果。为此，我们将扩展默认的地理搜索小部件，它默认使用谷歌地图，但由于有了<a href="https://www.algolia.com/doc/api-reference/widgets/geo-search/react/#connector"> connectGeoSearch连接器</a>，它可以被扩展。</p>
<p class="translated">注意:默认情况下，React InstantSearch与<a href="https://www.algolia.com/doc/guides/building-search-ui/going-further/server-side-rendering/react/">服务器端渲染</a>兼容，并具有<a href="https://www.algolia.com/doc/guides/building-search-ui/going-further/routing-urls/react/">完全路由能力</a>。</p>
<h2 class="translated"><a id="adding-react-instantsearch-to-our-app" class="anchor" href="#adding-react-instantsearch-to-our-app" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>向我们的应用添加React InstantSearch</h2>
<p class="translated">要将InstantSearch添加到我们的应用程序中，让我们安装所需的包。</p>
<pre class="lang:sh decode:true">yarn add algoliasearch react-instantsearch-dom</pre>
<p class="translated">为了类型脚本兼容性和IDE支持，我们还将添加<b> react-instantsearch </b>类型</p>
<p> </p>
<pre class="lang:sh decode:true ">yarn add -D @types/react-instantsearch</pre>
<p> </p>
<p class="translated">对于本指南的这一部分，这就是我们需要的全部内容。</p>
<p class="translated">我们先从Algolia的仪表盘上抓取一些信息。</p>
<p class="translated">在Algolia仪表盘上，点击<b>平台</b>图标(侧栏中的最后一个图标)并选择<b> API密钥</b>以复制您的仅搜索API密钥和应用ID。</p>
<p class="translated"><img loading="lazy" class="aligncenter wp-image-12477 size-full" src="../Images/4dfb7793403361e453fd5e42eae7f717.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/image5.png 1999w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image5-259x178.png 259w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image5-581x400.png 581w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image5-768x529.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image5-1536x1057.png 1536w" sizes="(max-width: 1999px) 100vw, 1999px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/image5.png"/></p>
<p class="translated">现在，让我们创建一个名为<code>.local.env</code>的文件。我们将把环境变量存储在这个文件中。这些变量将在构建时注入到我们的应用程序中，所以不要忘记在创建这个文件后重启本地开发服务器。</p>
<p class="translated">将以下内容添加到<code>.local.env</code>文件中:</p>
<pre class="lang:sh decode:true">REACT_APP_ALGOLIA_APP_ID=”myAppId”&#13;
REACT_APP_ALGOLIA_API_KEY=”xxxxx”&#13;
REACT_APP_ALGOLIA_INDEX_NAME=”myIndiceName”&#13;
</pre>
<p class="translated">注意:如果环境变量对你来说是新的，有很多非常好的资源，比如:我的朋友张秀坤Twilio的首席开发人员布道者——写的《在Node.js中使用环境变量》,可以帮助你快速了解这个主题。另一个很好的例子集中在<a href="https://create-react-app.dev/docs/adding-custom-environment-variables/">在Create React App应用程序中添加自定义环境变量</a>。</p>
<h3 class="translated"><a id="creating-the-algolia-client-instance" class="anchor" href="#creating-the-algolia-client-instance" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <b>创建Algolia客户端实例</b></h3>
<p class="translated">现在我们已经安装了所需的包，让我们将React InstantSearch添加到我们的应用程序中。第一步是在我们文件的顶部导入InstantSearch。</p>
<pre class="lang:js decode:true">import {&#13;
  InstantSearch,&#13;
} from 'react-instantsearch-dom';&#13;
</pre>
<p class="translated">然后，我们可以将即时搜索组件添加到代码中:</p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12540 size-full" src="../Images/c7ee501694daefb4e9f9376a39065957.png" alt="InstantSearch init code" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1.png 1712w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1-320x104.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1-720x234.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1-768x249.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1-1536x499.png 1536w" sizes="(max-width: 1712px) 100vw, 1712px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1.png"/></p>
<p class="translated">如您所见，它需要两个参数:</p>
<ul>
<li class="translated"><b> <code>indexName</code> </b>是您放入Algolia仪表盘的索引名称。</li>
<li class="translated"><b> <code>searchClient</code> </b>是AlgoliaSearch的一个实例，Algolia Search API的JavaScript客户端库，它将执行所有的请求。由于我们希望尽可能简单，我们将为这个实例添加一个单独的文件(此外，我们将在第三个视频中需要它，并且保持事物的分离在软件工程中总是一个好的实践)。</li>
</ul>
<p class="translated"><i>src/lib/algolia client . ts</i></p>
<pre class="lang:js decode:true">import algoliaSearch from 'algoliasearch';&#13;
&#13;
const indexName = process.env.REACT_APP_ALGOLIA_INDEX_NAME;&#13;
const searchClient = algoliaSearch( process.env.REACT_APP_ALGOLIA_APP_ID as string, process.env.REACT_APP_ALGOLIA_API_KEY as string );&#13;
&#13;
export { indexName, searchClient };&#13;
</pre>
<p class="translated">现在我们有了我们的客户机，是时候在我们的InstantSearch实例中使用它了。</p>
<h3 class="translated"><a id="adding-our-first-widget-to-instantsearch" class="anchor" href="#adding-our-first-widget-to-instantsearch" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <b>将我们的第一个小部件添加到即时搜索</b></h3>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12540 size-full" src="../Images/c7ee501694daefb4e9f9376a39065957.png" alt="InstantSearch init code" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1.png 1712w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1-320x104.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1-720x234.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1-768x249.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1-1536x499.png 1536w" sizes="(max-width: 1712px) 100vw, 1712px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-1.png"/></p>
<p class="translated">我们将使用<hits>小部件来显示Algolia返回的结果。</hits></p>
<p class="translated"><code>Hits</code>组件只接受一个属性:<code>hitComponent</code>，一个带有<b>项</b>作为参数的函数，它应该返回JSX。这个JSX将在应用程序中呈现。</p>
<pre class="lang:js decode:true ">&lt;Hits&lt;Hit&gt; hitComponent={&#13;
({ hit }) =&gt; (&#13;
      	&lt;StoreComponent&#13;
           	key={hit.objectID}&#13;
                onClick={(hit) =&gt; handleClick(hit)}&#13;
                hit={hit}&#13;
                currentStore={currentStoreCoordinates}&#13;
            /&gt;&#13;
      )}/&gt;&#13;
</pre>
<p class="translated">你可以返回任何你想要的JSX，但是我们已经创建了自己的组件，它只不过是一个带有一点CSS的<code>div</code>。</p>
<p class="translated">让我们更深入地了解一下它的道具:</p>
<ul>
<li class="translated"><b>键属性</b>用于帮助React识别它必须呈现的循环元素。，如果您对React不太熟悉，请查看关于<a href="https://reactjs.org/docs/lists-and-keys.html#keys">列表和键的文档——React</a>:</li>
<li class="translated"><b> onClick属性</b>用于处理项目上的鼠标事件。；</li>
<li class="translated">点击道具用于填充组件。</li>
<li class="translated">最后，<b> currentStore属性</b>用于让应用程序知道选择了哪个商店。通过比较两个LngLat坐标的比较位置，将pin更改为不同的颜色(在我们的例子中)会很有用。</li>
</ul>
<p class="translated"><i>src/lib/compare position . ts</i></p>
<pre class="lang:js decode:true ">export const comparePosition = (&#13;
  position1: [number, number],&#13;
  position2: [number, number] | null&#13;
): boolean =&gt; {&#13;
  return position2&#13;
    ? position1[0] === position2[0] &amp;&amp; position1[1] === position2[1]&#13;
    : false;&#13;
};&#13;
&#13;
</pre>
<p class="translated">现在我们已经创建了这个组件，我们应该会在我们的应用程序旁边看到一个漂亮的斯潘塞商店列表！</p>
<p class="translated"><video poster="https://res.cloudinary.com/hilnmyskv/image/upload/v1626774743/blogposts/store_locator_2021_list_preview.jpg" autoplay="autoplay" loop="loop" muted="muted"> <source type="video/mp4" src="https://res.cloudinary.com/hilnmyskv/image/upload/v1626774743/blogposts/store_locator_2021_list_preview.mp4"/> <source type="video/webm" src="https://res.cloudinary.com/hilnmyskv/image/upload/v1626774743/blogposts/store_locator_2021_list_preview.webm"/> </video></p>
<p class="translated">但事实是:它并不真正可用。当然，它做到了我们要求的(按受欢迎程度排序，但由于我住在法国北部(靠近里尔和比利时——美味的巧克力和上好的啤酒)，我绝对不关心亚特兰大的商店。</p>
<p class="translated">因此，让我们添加地理搜索功能，这样它就可以显示我周围最受欢迎的商店！</p>
<h3 class="translated"><a id="adding-geo-search" class="anchor" href="#adding-geo-search" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <b>添加地理搜索</b></h3>
<p class="translated">默认情况下，Algolia提供了执行地理搜索的可能性，无需传递任何纬度/经度，但仍会返回最近的命中结果。怎么会？它依赖于你用来调用Algolia API的IP地址。注意:对于欧盟的人，从2021年7月起，IP地址不被视为PII(个人身份信息，法语中“Donnée à caractère personnelle”的DCP ),因为它不精确定位用户，这意味着不需要警告用户您正在使用它来告诉InstantSearch我们想要使用“aroundLatLngViaIP ”,我们使用配置组件</p>
<p class="translated"><img loading="lazy" class="alignnone size-full wp-image-12546" src="../Images/98b91740045b97e6e0b92603efdf89e4.png" alt="InstantSearch ConfigureComponent" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-3.png 1714w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-3-320x78.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-3-720x176.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-3-768x187.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-3-1536x375.png 1536w" sizes="(max-width: 1714px) 100vw, 1714px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-3.png"/>注意:&lt;配置/ &gt;组件可以接受任何<a href="https://www.algolia.com/doc/api-reference/widgets/configure/react/">搜索参数</a>。我们将在下一集看到更多。</p>
<p class="translated">现在，您会看到列表显示了您所在位置附近的商店。最简单的实验方法是通过VPN。</p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td colspan="2">
<p class="translated"><figure id="attachment_12474" aria-describedby="caption-attachment-12474" class="wp-caption aligncenter"> <img loading="lazy" class="wp-image-12474 size-large" src="../Images/f5d3baba0263058c89c5d2f00c85a361.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/image1-206x400.png 206w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image1-92x178.png 92w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image1.png 724w" sizes="(max-width: 206px) 100vw, 206px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/image1-206x400.png"/> <figcaption id="caption-attachment-12474" class="wp-caption-text">与我的常规连接(🇫🇷) </figcaption> </figure></p></td>
<td colspan="2">
<p class="translated"><figure id="attachment_12480" aria-describedby="caption-attachment-12480" class="wp-caption aligncenter"> <img loading="lazy" class="wp-image-12480 size-large" src="../Images/dd6aab6bc5b098af0921c63ccc8a14ec.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/image8-169x400.png 169w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image8-75x178.png 75w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image8-648x1536.png 648w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image8.png 724w" sizes="(max-width: 169px) 100vw, 169px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/image8-169x400.png"/> <figcaption id="caption-attachment-12480" class="wp-caption-text">用VPN连接到一个希腊服务器(🇬🇷)(太阳来了🎵)</figcaption> </figure></p></td>
</tr>
</tbody>
</table>
<p class="translated">现在我们有了附近商店的列表，让我们添加一个漂亮的<b>细化列表</b>来过滤服务类型。</p>
<p class="translated">与<b> Hits </b>小部件不同，<b> RefinementList </b>组件只有一个属性，用于传递我们想要使用的方面<b>属性</b>的名称，这是我们在第1部分的<a href="https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-1/" target="_blank" rel="noopener">中的Algolia仪表盘中配置的。</a></p>
<p class="translated"><img loading="lazy" class="alignnone size-full wp-image-12547" src="../Images/cc8be5febb2fd32b161d12df585ddbe4.png" alt="InstantSearch Refinement list config" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-4.png 1714w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-4-320x78.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-4-720x176.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-4-768x187.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-4-1536x375.png 1536w" sizes="(max-width: 1714px) 100vw, 1714px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/carbon-4.png"/></p>
<h3 class="translated"><a id="styling-of-the-refinementlist" class="anchor" href="#styling-of-the-refinementlist" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <b>细化列表的样式</b></h3>
<p class="translated">Algolia在一个单独的包中提供了一个默认主题。要使用它，您需要添加<b> instantsearch.css </b>样式表，但是在我们的示例中，我想使用<b><i>@ apply</i></b><i/>指令与您一起探索一个定制的<b> Tailwindcss </b>主题，该指令允许您使用TailwindCSS的预定义类名来设计任何CSS选择器的样式，如下所示:</p>
<pre class="lang:css decode:true ">.ais-RefinementList ul {&#13;
  @apply flex font-normal text-sm flex-wrap gap-2 my-4;&#13;
}&#13;
&#13;
.ais-RefinementList ul li {&#13;
  @apply rounded bg-purple-200 px-2 py-1;&#13;
}&#13;
&#13;
.ais-RefinementList ul input {&#13;
  display: none;&#13;
}&#13;
&#13;
.ais-RefinementList-labelText {&#13;
  @apply font-medium text-purple-900;&#13;
}&#13;
&#13;
.ais-RefinementList-count {&#13;
  @apply font-black text-white p-1 px-1.5 bg-purple-400 rounded-full;&#13;
}&#13;
&#13;
.ais-RefinementList-item--selected {&#13;
  @apply border-2 border-purple-800;&#13;
}&#13;
&#13;
.aa-Panel mark {&#13;
  color: #5468ff;&#13;
  background: none;&#13;
}&#13;
</pre>
<p class="translated">一旦添加了这些样式，细化列表小部件应该大致如下所示:</p>
<p class="translated"><video poster="https://res.cloudinary.com/hilnmyskv/image/upload/v1626861899/blogposts/store_locator_2021_refinementlist.jpg" autoplay="autoplay" loop="loop" muted="muted"> <source type="video/mp4" src="https://res.cloudinary.com/hilnmyskv/image/upload/v1626861899/blogposts/store_locator_2021_refinementlist.mp4"/> <source type="video/webm" src="https://res.cloudinary.com/hilnmyskv/image/upload/v1626861899/blogposts/store_locator_2021_refinementlist.webm"/> </video></p>
<h1 class="translated"><a id="displaying-stores-on-a-map-using-mapbox" class="anchor" href="#displaying-stores-on-a-map-using-mapbox" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>使用地图框在地图上显示商店</h1>
<p class="translated">如果你已经完成了，这个应用程序在这个阶段应该是这样的:</p>
<p class="translated"><img loading="lazy" class="aligncenter wp-image-12486 size-full" src="../Images/e8a824887cc58eb60fd47e8d2b86ccc3.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/image14.png 1999w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image14-273x178.png 273w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image14-614x400.png 614w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image14-768x500.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image14-1536x1000.png 1536w" sizes="(max-width: 1999px) 100vw, 1999px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/image14.png"/></p>
<p class="translated">一个页眉，一个侧边的列表，和空白的空间。现在是时候用一张漂亮的地图来填满这个空间了！</p>
<h2 class="translated"><a id="choosing-the-right-map-provider" class="anchor" href="#choosing-the-right-map-provider" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>选择合适的地图提供商</h2>
<p class="translated">有几十个地图提供商，其中一些非常有名:</p>
<ul>
<li class="translated">谷歌地图，</li>
<li class="translated">苹果计划(从去年开始有一个网络框架)</li>
<li class="translated">地图框(我们将使用的那个)</li>
<li class="translated">(由诺基亚和戴姆勒领导的财团——梅赛德斯-奔驰、斯玛特、克莱斯勒……)</li>
<li class="translated">JawgMaps</li>
<li class="translated">和传单(开源)</li>
</ul>
<p class="translated">默认情况下，Algolia的React InstantSearch库内置了一个用于谷歌地图的w<a href="https://www.algolia.com/doc/api-reference/widgets/geo-search/react/">id get</a>。不过，为了向您展示如何集成任何其他地图提供商，我们将使用<a href="https://www.mapbox.com/use-cases/store-locator">Mapbox.com</a>构建我们新的地理搜索小部件，因为它们提供强大的React和TypeScript支持以及全球地图覆盖。</p>
<p class="translated">在我们的环境中，Mapbox有一个巨大的领域优势:一个我们将在本系列的第三集中使用的非常完善的API，加上他们使用开源堆栈的事实:</p>
<ul>
<li class="translated">渲染引擎的传单. js</li>
<li class="translated">OpenStreetMap (OSM)获取数据</li>
<li class="translated">用于设计的卡通</li>
</ul>
<p class="translated">所以从Mapbox切换到另一个提供商应该不会很痛苦。</p>
<p class="translated"><img loading="lazy" class="aligncenter wp-image-12502 size-full" src="../Images/33e29cf099fca2343ae73707ebe9b5d2.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/image30.png 1999w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image30-226x178.png 226w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image30-509x400.png 509w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image30-768x604.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image30-1536x1207.png 1536w" sizes="(max-width: 1999px) 100vw, 1999px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/image30.png"/></p>
<p class="translated">在创建了你的地图箱账户后，你应该会看到类似的东西。复制您的<code>Default Public Token</code>，并将其复制到您的<b> .local.env </b>文件中:</p>
<p class="translated"><code>REACT_APP_MAPBOX_TOKEN=pk.your_token_here</code></p>
<p class="translated">现在，让我们通过在终端中键入来安装Mapbox包装器</p>
<p class="translated"><code>yarn add react-mapbox-gl mapbox-gl</code>T3】</p>
<p class="translated">接下来，我们在<b>组件</b>下创建一个<b> MapComponent </b>目录，并添加一个<b> MapComponent.tsx </b>文件。</p>
<p class="translated">导入所需的包，并搭建类组件:</p>
<pre class="lang:js decode:true ">import React, { Component } from 'react';&#13;
import ReactMapboxGl, { ZoomControl, Marker } from 'react-mapbox-gl';&#13;
import { Map } from 'mapbox-gl';&#13;
&#13;
interface IMapState {&#13;
  lat: number;&#13;
  lng: number;&#13;
  zoom: number;&#13;
}&#13;
&#13;
interface IMapProps {}&#13;
&#13;
// Required to init the map&#13;
const ReactMap = ReactMapboxGl({&#13;
  accessToken: process.env.REACT_APP_MAPBOX_TOKEN as string,&#13;
});&#13;
&#13;
class MapComponent extends Component&lt;IMapProps, IMapState&gt; {&#13;
  map: any;&#13;
&#13;
  state = {&#13;
    lat: 30.5,&#13;
    lng: 50.5,&#13;
    zoom: 9,&#13;
  };&#13;
&#13;
  render() {&#13;
    return (&#13;
      &lt;div className={'h-full w-full relative'}&gt;&#13;
        &lt;div className={'h-full w-full'}&gt;&#13;
          &lt;ReactMap&#13;
            ref={(e) =&gt; {&#13;
              this.map = e.state.map;&#13;
            }}&#13;
            {/* This is the style, we’ll use the light one but you can try street-v10 */}&#13;
            style="mapbox://styles/mapbox/light-v10"&#13;
            containerStyle={{&#13;
              height: '100%',&#13;
              width: '100%',&#13;
              position: 'relative',&#13;
              display: 'block',&#13;
           }}&#13;
          &gt;&#13;
            &lt;&gt;&#13;
           	//This adds a little +/- control to zoom in / out&#13;
      &lt;ZoomControl position={'bottom-right'} /&gt;&#13;
            &lt;/&gt;&#13;
          &lt;/ReactMap&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
    );&#13;
  }&#13;
}&#13;
&#13;
export default MapComponent;&#13;
</pre>
<p class="translated">由于react-mapbox-gl，我们刚刚添加了一个全尺寸地图。</p>
<p class="translated">通过在<b> App.tsx </b>中注入您新创建的组件，您应该会看到类似这样的内容，所以现在是添加标记的时候了！</p>
<p class="translated">呃…不！那就太简单了。要做到这一点，您需要将它添加到您的craco.config.js文件中，该文件是我们上周创建的，用于处理PostCSS插件。</p>
<pre class="lang:json decode:true ">styles:{&#13;
//...postCSS stuff here&#13;
},&#13;
babel: {&#13;
    loaderOptions: {&#13;
      ignore: ['./node_modules/mapbox-gl/dist/mapbox-gl.js'],&#13;
    },&#13;
  },&#13;
</pre>
<p class="translated">npm上的<b> mapbox-gl </b>库已经被传输，所以我们需要告诉babel(我们的传输程序)到<b>而不是</b>trans file map box-GL . js .<img loading="lazy" class="aligncenter wp-image-12487 size-full" src="../Images/685b40d2f8040f5a09e3cb4599aea8d4.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/image15.png 1999w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image15-273x178.png 273w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image15-614x400.png 614w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image15-768x500.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image15-1536x1000.png 1536w" sizes="(max-width: 1999px) 100vw, 1999px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/image15.png"/></p>
<p class="translated">现在我们显示地图，我们需要添加它的“动态”行为。</p>
<h2 class="translated"><a id="creating-a-customwidget-with-connectgeosearch" class="anchor" href="#creating-a-customwidget-with-connectgeosearch" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <b>使用connectGeoSearch创建自定义小部件</b></h2>
<p class="translated">现在是时候将地图连接到React InstantSearch实例了。为此，我们将利用connectGeoSearch，这是React InstantSearch中公开的一个高阶组件。</p>
<p class="translated">让我们导入所需的插件:</p>
<p class="translated"><code>import { connectGeoSearch } from 'react-instantsearch-dom';</code></p>
<p class="translated"><code>import type { GeoSearchProvided } from 'react-instantsearch-core';</code></p>
<p class="translated">第一个导入库本身，第二个导入TypeScript和IntelliSense所需的类型。</p>
<p class="translated">首先，我们将稍微更新一下我们的MapComponent类声明:</p>
<p class="translated"><code>class MapComponent extends Component&lt;<b>GeoSearchProvided &amp; IMapProps</b>, IMapState&gt;</code></p>
<p class="translated">我们将稍微改变导出组件的方式:</p>
<p class="translated"><code>export default connectGeoSearch(MapComponent)</code>；</p>
<p class="translated">在这之后，我们的地图渲染不会有任何变化<b>但是</b>如果我们打开React DevTools并搜索我们的地图组件，就会有一些变化…</p>
<p class="translated"><img loading="lazy" class="aligncenter wp-image-12507 size-full" src="../Images/1bf900526cd3b3525496667d6a02753e.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/image35.png 1244w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image35-174x178.png 174w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image35-391x400.png 391w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image35-768x785.png 768w" sizes="(max-width: 1244px) 100vw, 1244px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/image35.png"/></p>
<p class="translated">我们看到我们的MapComponent现在有一个包含所有Algolia索引记录的属性。现在，我们可以专注于在地图上显示那些标记。</p>
<p class="translated">让我们在状态接口中添加一个标记数组<code>marker: []</code>，在填充每个商店的坐标之前，我们将其初始化为一个空数组..</p>
<p class="translated">为了在从Algolia接收到新的JSON响应时更新显示的标记，我们将使用React的生命周期方法<b> <code>componentWillReceiveProps</code> </b>，其中我们将添加与向地图添加标记相关的逻辑。</p>
<pre class="lang:js decode:true ">componentWillReceiveProps(nextProps){&#13;
// Let’s grab hits from nextProps and let’s compare if the two are not empty and differents from those already in props. 	 &#13;
    const { hits } = nextProps;&#13;
    if (hits.length &amp;&amp; hits !== this.props.hits) {&#13;
&#13;
	// If so let’s grab coordinates from the hit and store them into an temp array&#13;
      const markers: [number, number][] = hits.map(&#13;
        ({ _geoloc }: { _geoloc: { lat: number; lng: number } }) =&gt; {&#13;
          return [_geoloc.lng, _geoloc.lat];&#13;
        }&#13;
      );&#13;
	&#13;
// Finally let’s store this in our component state, and update the map accordingly (by centering it to the first marker) We’ll check this method in a minute, you can comment it for now.&#13;
      this.setState({ markers }, () =&gt; {&#13;
        //this.centerMapOnCoordinates(this.state.markers[0]);&#13;
      });&#13;
    }&#13;
}&#13;
</pre>
<p class="translated">为了在地图上显示标记，让我们在MapComponent目录中创建一个<StoreMarker/>组件。这一个有1个属性—<b>is selected</b>——如果商店被选中就改变标记。这是一个非常简单的组件，所以我将在这里包括它。</p>
<pre class="lang:js decode:true ">import React from "react";&#13;
import { ReactComponent as MarkerPin } from '../../marker.svg';&#13;
import { ReactComponent as MarkerPinSelected } from '../../marker-selected.svg';&#13;
&#13;
const StoreMarker: React.FC&lt;{isSelected: boolean}&gt; = ({isSelected}) =&gt; {&#13;
  return isSelected ? &lt;MarkerPinSelected className={'shadow-lg cursor-pointer'}/&gt; : &lt;MarkerPin className={'shadow-lg cursor-pointer'}/&gt;;&#13;
}&#13;
&#13;
export default StoreMarker&#13;
</pre>
<p class="translated">现在，让我们通过将组件包装在MapboxGL <Marker/>组件中，为组件增加一层额外的复杂性。它将负责向地图添加标记。它只需要一个道具(对于我们的例子来说，但还有一堆可用的):<b>坐标:</b></p>
<pre class="lang:js decode:true ">…&#13;
import {Marker} from "react-mapbox-gl";&#13;
&#13;
const StoreMarker: React.FC&lt;{isSelected: boolean, coordinates: [number, number]}&gt; = ({isSelected, coordinates}) =&gt; {&#13;
  return &lt;Marker coordinates={coordinates}&gt;&#13;
    {isSelected ? &lt;MarkerPinSelected className={'shadow-lg cursor-pointer'}/&gt; : &lt;MarkerPin className={'shadow-lg cursor-pointer'}/&gt;}&#13;
  &lt;/Marker&gt;&#13;
}&#13;
</pre>
<p class="translated">现在，在MapComponent中，让我们“映射”我们的标记以在地图上显示它们！</p>
<pre class="lang:js decode:true ">MapComponent/MapComponent.tsx&#13;
&lt;&gt;&#13;
  {this.state.markers.map((position) =&gt; {&#13;
  return (&#13;
&lt;StoreMarker isSelected={false} coordinates={position}/&gt;&#13;
);&#13;
  })}&#13;
 &lt;ZoomControl position={'bottom-right'} /&gt;&#13;
&lt;/&gt;&#13;
</pre>
<p class="translated"><img loading="lazy" class="aligncenter wp-image-12497 size-full" src="../Images/0e5b7f3ecfb2955dc2bbfed33a8d3570.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/image25.png 1999w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image25-273x178.png 273w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image25-614x400.png 614w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image25-768x500.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image25-1536x1000.png 1536w" sizes="(max-width: 1999px) 100vw, 1999px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/image25.png"/></p>
<p class="translated">我们现在应该有标记渲染在我们的地图上。</p>
<p class="translated">现在是时候“提炼”这个，并在给定的标记上将地图居中。但是在仔细观察<b> <code>centerMapOnCoordinates</code> </b>之前，让我们添加另一个生命周期方法来避免无关的渲染。在这里，我们只是检查两个命中数组是否不同，并在相反的情况下阻止渲染。</p>
<pre class="lang:js decode:true ">shouldComponentUpdate(nextProps: Readonly&lt;GeoSearchProvided&gt;): boolean {&#13;
    return nextProps.hits !== this.props.hits;&#13;
}&#13;
</pre>
<p class="translated">接下来我们来看<b> <code>centerMapOnCoordinates</code> </b>。这可能是本周部分中最复杂的代码。</p>
<p class="translated">注意:如果您想了解关于不同步骤的更多信息，请不要犹豫观看本文顶部的livecoding。</p>
<p class="translated">所以让我们分开来看:</p>
<p class="translated">如果调用是由地图上的用户动作触发的，我们使用isUserInterraction状态布尔来避免进入地图。</p>
<p class="translated">如果不是，我们暂时将其设置为true，并将地图集中在第一个标记上(根据我们的配置，这是视口中具有最高人气属性的商店)。</p>
<p class="translated">然后，我们调用钩子提供的refine方法，该方法允许我们基于地图边界请求Algolia的数据:这里是东北和西南(右上和左下)。</p>
<pre class="lang:js decode:true ">centerMapOnCoordinates(coordinates: [number, number]) {&#13;
    if (!this.state.isUserInteraction) {&#13;
      const { refine } = this.props;&#13;
      this.setState({ isUserInteraction: true }, () =&gt; {&#13;
        this.map.state.map.flyTo({&#13;
          essential: false,&#13;
          center: [coordinates[0], coordinates[1]],&#13;
          zoom: 7,&#13;
        });&#13;
&#13;
&#13;
        refine({&#13;
          northEast: this.map.state.map.getBounds().getNorthEast(),&#13;
          southWest: this.map.state.map.getBounds().getSouthWest(),&#13;
        });&#13;
      });&#13;
    }&#13;
  }&#13;
</pre>
<p class="translated"><img loading="lazy" class="aligncenter size-large wp-image-12493" src="../Images/42915710bff148595ef6a6412b137ae7.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/image21-403x400.png 403w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image21-179x178.png 179w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image21-150x150.png 150w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image21-768x763.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/image21.png 1079w" sizes="(max-width: 403px) 100vw, 403px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/image21-403x400.png"/></p>
<h2 class="translated"><a id="add-%e2%80%9crefresh-as-the-map-moves%e2%80%9d-option-%c2%a0" class="anchor" href="#add-%e2%80%9crefresh-as-the-map-moves%e2%80%9d-option-%c2%a0" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <b>添加“随着地图移动而刷新”选项。</b></h2>
<p class="translated">当我们移动地图时，这个地图组件中需要的最后一个方法将用于细化地图标记！这是一个不言自明的方法。我们已经使用了之前在它的主体中调用的所有方法。</p>
<pre class="lang:js decode:true ">onMapInteraction(map: Map) {&#13;
    if (this.state.userInteractionEnabled) {&#13;
      const { refine } = this.props;&#13;
&#13;
      refine({&#13;
        northEast: map.getBounds().getNorthEast(),&#13;
        southWest: map.getBounds().getSouthWest(),&#13;
      });&#13;
    }&#13;
  }&#13;
</pre>
<p class="translated">这里唯一的新参数是<b> <code>userInteractionEnabled</code> </b>布尔值，它根据我们接下来要添加的复选框而变化！</p>
<p class="translated">为了处理这个问题，并使我们的代码尽可能清晰，让我们在MapComponent/目录中创建一个新的组件。我们将再次称它为<b> SearchAsMoving </b>以保持我们的组件简单和愚蠢(KISS方法论)。这是一个简单的div，带有一个文本和一个<code>input type=”checkbox”</code></p>
<pre class="lang:js decode:true ">interface ISearchAsMoving {&#13;
  checked: boolean,&#13;
  onChange: (checked: boolean) =&gt; void&#13;
}&#13;
&#13;
const SearchAsMoving: React.FC&lt;ISearchAsMoving&gt; = ({checked, onChange}) =&gt; {&#13;
  return (&#13;
    &lt;div&gt;&#13;
      &lt;input&#13;
        defaultChecked={checked}&#13;
        type={'checkbox'}&#13;
        onChange={(e) =&gt;&#13;
          onChange(e.target.checked)&#13;
        }&#13;
      /&gt;&#13;
      Search when I move the map&#13;
    &lt;/div&gt;&#13;
  )&#13;
}&#13;
&#13;
export default SearchAsMoving&#13;
</pre>
<p class="translated">我们向这个方法传递两个属性，默认的检查状态(checked)和当我们改变复选框的状态时我们想要触发的方法。</p>
<p class="translated">我们现在可以将它添加到我们的地图中，在<ReactMap/>组件下，我们会很好的！</p>
<pre class="lang:js decode:true ">&lt;SearchAsMoving &#13;
    checked={this.state.userInteractionEnabled}   onChange={(userInteractionEnabled) =&gt; this.setState({userInteractionEnabled})}/&gt;&#13;
</pre>
<p class="translated">完成后，让我们将<b> <code>onMapInteraction</code> </b>添加到地图中，让我们结束吧！</p>
<pre class="lang:js decode:true ">&lt;ReactMap&#13;
            ref={(e) =&gt; { this.map = e?.state.map; }}&#13;
            style={...}&#13;
            containerStyle={{...}}&#13;
            onMoveEnd={this.onMapInteraction}&#13;
&gt;...&#13;
</pre>
<p class="translated"><video poster="https://res.cloudinary.com/hilnmyskv/image/upload/v1626774992/blogposts/store_locator_2021_map_preview.jpg" autoplay="autoplay" loop="loop" muted="muted"> <source type="video/mp4" src="https://res.cloudinary.com/hilnmyskv/image/upload/v1626774992/blogposts/store_locator_2021_map_preview.mp4"/> <source type="video/webm" src="https://res.cloudinary.com/hilnmyskv/image/upload/v1626774992/blogposts/store_locator_2021_map_preview.webm"/> </video></p>
<h2 class="translated"><a id="let%e2%80%99s-wrap-up" class="anchor" href="#let%e2%80%99s-wrap-up" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>让我们总结一下吧！</h2>
<p class="translated">基于上周的工作:</p>
<ul>
<li class="translated">我们首先使用<instantsearch>和<hits>包装器将数据添加到边列表中</hits></instantsearch></li>
<li class="translated">我们已经用<Configure/>组件改进了这个列表，并且我们传递了‘aroundLatLngViaIP’以便得到我们周围的结果。</li>
<li class="translated">我们已经使用Mapbox创建了一个地图</li>
<li class="translated">我们已经使用connectGeoSearch() HOC将其连接到React InstantSearch实例。</li>
<li class="translated">最后，我们添加了一个搜索，因为我移动地图复选框，以改善我们的UX。</li>
</ul>
<p class="translated">我们将在第3部分看到</p>
<ul>
<li class="translated">如何添加允许搜索位置的自动完成功能</li>
<li class="translated">如何使用Twilio在商店有产品时发送文本消息</li>
</ul>
<p class="translated"><span>注</span>:今天会话的代码在<a href="https://github.com/algolia-samples/store-locator-with-algolia-mapbox-twilio/tree/session-2-adding-instant-search-end"> Github库</a>中。</p>
</div></div>    
</body>
</html>