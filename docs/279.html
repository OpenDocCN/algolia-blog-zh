<html>
<head>
<title>Building server-rendered search for static sites with 11ty Serverless, Netlify, and Algolia - Algolia Blog | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用11ty Serverless、Netlify和Algolia-Algolia Blog | Algolia Blog为静态网站构建服务器呈现的搜索</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/building-server-rendered-search-for-static-sites-with-11ty-serverless-netlify-and-algolia/#0001-01-01">https://www.algolia.com/blog/engineering/building-server-rendered-search-for-static-sites-with-11ty-serverless-netlify-and-algolia/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="translated">在创建任何网站或应用程序时，渐进式改进都是一个重要的主题。当用户的浏览器不能处理任何JavaScript或您正在使用的特定JavaScript时会发生什么？如果您的前端出现故障，您需要一个后备来允许基本功能继续工作。</p>
<p class="translated">这有什么难的？</p>
<p class="translated">当您在Jamstack上工作时，这可能比在传统堆栈中工作要困难得多。由于Jamstack致力于从CDN提供HTML，我们没有传统的服务器，只有静态文件和无服务器功能。因此，我们可能会发现自己在为前端和服务器重写渲染代码。三年和重新设计过去了，突然你在时间机器里看着去年设计的搜索结果。</p>
<p class="translated">有了11ty新的无服务器包和Netlify功能，我们可以从服务器快速启动。在此基础上，我们可以逐步增强使用InstantSearch.js等库的体验。</p>
<h2 class="translated"><a id="what-is-11ty-serverless" class="anchor" href="#what-is-11ty-serverless" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>什么是11ty无服务器？</h2>
<p class="translated">11ty是一个用Node.js编写的静态站点生成器，它提供了多种模板语言和多种获取数据的方法。它的构建考虑到了灵活性。</p>
<p class="translated">历史上，它在构建过程中完成所有工作，并生成可以存储在CDN上的HTML。这就创建了在Jamstack上运行得非常好的快速网站。</p>
<p class="translated">对于任何动态内容，它都依赖前端JavaScript来获取数据。这在许多情况下都有效，但是没有提供明确的渐进增强的途径。</p>
<p class="translated">如果你的前端代码失败了，你的站点的动态方面也会随之失败。随着11ty 1.0版本的发布，这将不再是一个问题。11ty将捆绑可选的11ty无服务器插件。这将允许开发者指定可以处理用户输入的路由。该输入可以来自查询参数或URL结构本身。</p>
<h2 class="translated"><a id="what-were-building" class="anchor" href="#what-were-building" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>我们在建设什么</h2>
<p class="translated"><img loading="lazy" class="alignnone size-medium wp-image-13060" src="../Images/0a4a6cf2ffa34aafb3be37f2709069b1.png" alt="Screenshot showcasing the final serverless search page" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/10/11ty-serverless-screenshot-241x178.png 241w, https://blog-api.algolia.com/wp-content/uploads/2021/10/11ty-serverless-screenshot-541x400.png 541w, https://blog-api.algolia.com/wp-content/uploads/2021/10/11ty-serverless-screenshot-768x568.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/10/11ty-serverless-screenshot-1536x1136.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/10/11ty-serverless-screenshot-2048x1514.png 2048w" sizes="(max-width: 241px) 100vw, 241px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/10/11ty-serverless-screenshot-241x178.png"/></p>
<p class="translated">在这个演示中，我们将采用一个非常简单的11ty站点，并添加一个动态搜索路线。该搜索路径将使用11ty和一个模板过滤器在一个无服务器的函数中创建HTML所有这些都来自我们习惯的11ty代码。这将用于我们渐进增强中的“后退”。虽然我们不会在这个演示中构建一个基于JavaScript的搜索，但是使用InstantSearch.js 创建一个<a href="https://www.algolia.com/doc/guides/building-search-ui/what-is-instantsearch/js/?utm_source=blog&amp;amp;utm_medium=main-blog&amp;amp;utm_campaign=devrel-jamstack&amp;amp;utm_id=11ty-serverless">实时搜索是一个坚实的用户体验的基础。</a></p>
<p class="translated">我们将如何构建它:</p>
<p class="translated">1.安装插件并配置无服务器功能<br/> 2。创建搜索页面<br/> 3。创建一个<code>getResults</code>模板过滤器来查询我们的Algolia索引</p>
<h2 class="translated"><a id="setup" class="anchor" href="#setup" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>设置</h2>
<p class="translated">我们将从一个基本的11ty模板开始，只需要一点HTML就可以了。</p>
<p class="translated">首先，<a href="https://github.com/brob/11ty-serverless-search">克隆这个库</a>并安装依赖项(11ty 1.0和dotenv)。</p>
<p class="translated">想看看成品吗？检查存储库的<code>final</code>分支或者<a href="https://11ty-search.netlify.app/">查看这个演示站点</a>。</p>
<pre class="lang:sh decode:true ">npm install &amp;&amp; npm start&#13;
</pre>
<p class="translated">我们项目的结构遵循11ty站点的基本结构。各个页面都在项目的根目录下——目前只有<code>index.html</code>文件。模板在<code>_includes</code>目录中。配置文件是根目录下的<code>.eleventy.js</code>。站点模板也相对简单:一个包含页眉和页脚的基础模板。</p>
<p class="translated">一旦安装完成，我们将有一个本地运行的11ty工作站点。还不是很有意思，只是一个带一点HTML的索引页面。让我们添加一个搜索页面来引入一些内容。</p>
<h2 class="translated"><a id="install-and-configure-the-11ty-serverless-plugin" class="anchor" href="#install-and-configure-the-11ty-serverless-plugin" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>安装并配置11ty无服务器插件</h2>
<p class="translated">在其最新的1.0“金丝雀”版本中，11ty附带了插件11ty无服务器。这有助于生成我们需要按需运行11ty的无服务器功能。</p>
<p class="translated">为了在我们的项目中安装它，我们需要更新<code>.eleventy.js</code>配置文件。</p>
<pre class="lang:javascript decode:true ">require("dotenv").config();  &#13;
const { EleventyServerlessBundlerPlugin } = require("@11ty/eleventy");  &#13;
&#13;
module.exports = function(eleventyConfig) {  &#13;
    // Configuration rules  &#13;
    eleventyConfig.addPlugin(EleventyServerlessBundlerPlugin, {  &#13;
       name: "search", // The serverless function name for the permalink object &#13;
       functionsDir: "./netlify/functions/",  &#13;
     });  &#13;
};&#13;
</pre>
<p class="translated">由于11ty正在我们的项目中创建我们不想在版本控制中跟踪的文件，请用以下项目更新您的<code>.gitignore</code>:</p>
<pre class="lang:sh decode:true ">netlify/functions/search/**  &#13;
!netlify/functions/search/index.js&#13;
</pre>
<p class="translated">当我们重新运行<code>npm start</code>时，11ty现在将在<code>functionsDir</code>指定的目录中创建一个无服务器函数——以及所有必要的包文件，其名称由<code>name</code>属性指定。</p>
<p class="translated">在大多数情况下，您不会修改这些文件。该插件生成了<code>index.js</code>文件，可以对其进行编辑以用于更高级的用例。11ty将在每次运行时覆盖该目录中的其他文件。</p>
<h2 class="translated"><a id="create-a-page-to-use-the-serverless-function" class="anchor" href="#create-a-page-to-use-the-serverless-function" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>创建页面使用无服务器功能</h2>
<p class="translated">现在11ty已经创建了该函数，我们可以添加一个页面来使用它。</p>
<p class="translated">首先在项目的根目录下创建一个名为<code>search.html</code>的新文件。在文件中，我们可以用frontmatter配置页面的数据。</p>
<pre class="lang:javascript decode:true ">---  &#13;
layout: "base.html"  &#13;
title: Search Page  &#13;
permalink:  &#13;
 search: /search/  &#13;
---&#13;
</pre>
<p class="translated">变量<code>layout</code>将指示使用<code>_includes</code>中的哪个模板进行显示。变量<code>title</code>将显示在HTML的<code/></p>
<p class="translated">The <code>permalink</code>对象中，我们在这里指定这个页面的最终URL应该是什么。</p>
<p class="translated">如果你熟悉11ty，你可能记得<code>permalink</code>变量是一个字符串。对于简单的用例，您仍然可以使用字符串，但是对于无服务器，它将是一个对象。对象的键将是我们在无服务器功能的配置中指定的名称。</p>
<p class="translated">您也可以通过这种方式根据URL指定不同的无服务器功能。如果希望在构建时和请求时生成页面，也可以为permalink指定一个<code>build</code>键。</p>
<p class="translated">一旦添加，页面将在<code>/search/</code>呈现。除了页眉和页脚之外，它没有任何内容。让我们从查询参数中获取一些动态内容。</p>
<pre class="lang:javascript decode:true ">---&#13;
layout: "base.html"&#13;
title: Search Page&#13;
permalink:&#13;
  search: /search/&#13;
---&#13;
&#13;
&lt;h2 class="is-size-3 mb-3"&gt;This list is built at request from the query "{{ eleventy.serverless.query.query }}"&lt;/h2&gt;&#13;
</pre>
<p class="translated">这将创建一个标题，查看我们路线的查询参数，并插入<code>query</code>参数包含的任何值。</p>
<p class="translated">如果您访问URL末尾带有<code>?query=11ty</code>的页面，字符串<code>11ty</code>将出现在标题中。</p>
<p class="translated">那么，我们如何进行查询并从Algolia得到结果呢？</p>
<h2 class="translated"><a id="create-a-getresults-template-filter" class="anchor" href="#create-a-getresults-template-filter" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>创建一个<code>getResults</code>模板过滤器</h2>
<p class="translated">为了获得呈现模板所需的数据，我们需要创建一个模板过滤器。过滤器将接受来自无服务器页面的查询字符串，根据Algolia索引运行查询，并将一组文章返回到我们的搜索页面。</p>
<p class="translated">在我们深入研究代码之前，您需要有一个Algolia应用程序和一些环境变量。如果你已经有一个Algolia索引，请随意使用。我们将使用一个索引，其中包含带有标题、描述和URL的博客文章。如果您没有Algolia指数，<a href="https://www.algolia.com/users/sign_up?utm_source=blog&amp;utm_medium=main-blog&amp;utm_campaign=devrel-jamstack&amp;utm_id=11ty-serverless">创建一个帐户和应用程序</a>，并使用这些数据手动创建您的第一个指数。</p>
<pre class="lang:json decode:true ">[&#13;
    {&#13;
        "title": "Creating an omnibar with Autocomplete",&#13;
        "description": "In this tutorial, we’ll walk through setting up Autocomplete to fire interactions with JavaScript. Specifically, we’ll build an omnibar to toggle light and dark mode for our website. An omnibar is a search field that has both search and actions that can be taken. A strong example of this is the Chrome or Firefox search and URL bar.",&#13;
        "url": "https://www.algolia.com/blog/engineering/creating-an-omnibar-with-autocomplete/"&#13;
    },&#13;
    {&#13;
        "title": "Building a Store Locator in React using Algolia, Mapbox, and Twilio – Part 1",&#13;
        "description": "These days, ecommerce shoppers expect convenience and want the physical and online worlds to mesh allowing them to conduct their business on whichever channel they want. For example, users may choose to:",&#13;
        "url": "https://www.algolia.com/blog/engineering/building-a-store-locator-in-react-using-algolia-mapbox-and-twilio-part-1/"&#13;
    },&#13;
    {&#13;
        "title": "Introducing Algolia Recommend: The next best way for developers to increase revenue",&#13;
        "description": "Now, with the introduction of Algolia Recommend, Algolia further enables developers to unleash the component of the experience that drives the remaining part of the product discovery experience: product recommendations. ",&#13;
        "url": "https://www.algolia.com/blog/product/introducing-algolia-recommend-the-next-best-way-for-developers-to-increase-revenue/"&#13;
    }&#13;
]&#13;
</pre>
<p class="translated">一旦有了索引，创建一个<code>.env</code>文件并添加以下变量:</p>
<pre class="lang:sh decode:true "># The app id&#13;
ALGOLIA_APP = ""&#13;
# The search-only API key&#13;
ALGOLIA_SEARCH_KEY = ""&#13;
# The index name&#13;
ALGOLIA_INDEX = ""&#13;
</pre>
<p class="translated">一旦这些都准备好了，我们就可以通过Algolia JavaScript客户端提交查询来获得结果。因为我们的查询可以在模板中访问，所以我们将创建一个新的模板过滤器来使用查询并返回结果。</p>
<p class="translated">要创建一个新的过滤器，我们需要在<code>.eleventy.js</code>配置文件中扩展11ty。</p>
<p class="translated">首先，我们将安装<code>algoliasearch</code> NPM软件包。</p>
<pre class="lang:sh decode:true ">npm install algoliasearch&#13;
</pre>
<pre class="lang:javascript decode:true ">require("dotenv").config();&#13;
const { EleventyServerlessBundlerPlugin } = require("@11ty/eleventy");&#13;
const algoliasearch = require("algoliasearch");&#13;
&#13;
const client = algoliasearch(process.env.ALGOLIA_APP, process.env.ALGOLIA_SEARCH_KEY);&#13;
const index = client.initIndex(process.env.ALGOLIA_INDEX);&#13;
&#13;
module.exports = function (eleventyConfig) {&#13;
  eleventyConfig.addPlugin(EleventyServerlessBundlerPlugin, {&#13;
    name: "search", // The serverless function name from your permalink object&#13;
    functionsDir: "./netlify/functions/",&#13;
  });&#13;
&#13;
  eleventyConfig.addFilter("getResults", function (query) {&#13;
    return index.search(query, {&#13;
      attributesToRetrieve: ["title", "url", "date", "description"],&#13;
&#13;
    }).then(res =&gt; {&#13;
      return res.hits;&#13;
    })&#13;
  });&#13;
&#13;
};&#13;
</pre>
<p class="translated">在文件的顶部，我们将使用API键、应用程序名称和索引名称来设置Algolia搜索客户端。之后，在导出的函数内部，我们将使用11ty的<code>addFilter()</code>方法添加一个过滤器。</p>
<p class="translated">该方法接受两个参数:用作过滤器的字符串和使用时要执行的函数。该函数将接收从页面文件传递的数据。在这种情况下，它将是用户输入的查询。</p>
<p class="translated">在这个简单的例子中，我们将查询传递给<code>index.search()</code>方法，并只请求回我们需要的属性，以保持我们的响应较小。当结果返回时，我们可以将结果返回到我们的页面，以便在模板循环中使用。</p>
<pre class="lang:javascript decode:true ">---&#13;
layout: "base.html"&#13;
title: Search Page&#13;
permalink:&#13;
  search: /search/&#13;
---&#13;
&#13;
&lt;h2 class="is-size-3 mb-3"&gt;This list is built at request from the query "{{ eleventy.serverless.query.query }}"&lt;/h2&gt;&#13;
&#13;
{% assign results = eleventy.serverless.query.query | getResults %}&#13;
&lt;div class="card-grid"&gt;&#13;
  {% for result in results %}&#13;
    {% include "article.html" %}&#13;
  {% endfor %}&#13;
&lt;/div&gt;&#13;
</pre>
<p class="translated">在页面中，我们使用Liquid中内置的<code>assign</code>标签将数据赋给一个变量。然后，我们可以遍历返回的数组，并将该信息传递给include。这个include可以用于这些结果以及网站上的任何文章显示。应该在<code>_includes</code>目录中创建<code>article.html</code>文件。</p>
<pre class="lang:javascript decode:true ">&lt;article class="card column"&gt;&#13;
    &lt;h2 class="title"&gt;&lt;a href="{{ result.url }}"&gt;{{ result.title }}&lt;/a&gt;&lt;/h2&gt;&#13;
    &lt;p class="content"&gt;{{ result.description }}&lt;/p&gt;&#13;
&lt;/article&gt;&#13;
</pre>
<p class="translated">由于11ty无服务器，我们现在在静态生成的网站中有了一个工作服务器呈现的搜索。11ty无服务器可以帮助我们克服静态站点中的其他模式吗？在我们的开源代码交换平台上查看相关解决方案。</p>
<p class="translated"><a class="aligncenter" href="https://www.algolia.com/developers/code-exchange/?query=netlify&amp;page=1"> <img loading="lazy" class="wp-image-13777" src="../Images/7665551c18b687f25dcadc15cb213b7d.png" alt="" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2022/01/CodeX@2x.png"/> </a> <br/></p>
</div></div>    
</body>
</html>