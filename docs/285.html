<html>
<head>
<title>GraphQL search and indexing with Algolia - Algolia Blog | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL搜索和索引与Algolia - Algolia博客</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/graphql-search-and-indexing-with-algolia/#0001-01-01">https://www.algolia.com/blog/engineering/graphql-search-and-indexing-with-algolia/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="translated">GraphQL在web上的广泛使用，给开发者带来了很多优势。在前端，它减少了往返，并实现了更好的客户端缓存。在后端，它通过生成自描述的基于模式的API简化了微服务的多样性。在本文中，我们将看到如何增强GraphQL搜索功能。</p>
<p class="translated">Algolia与GraphQL有一些相同的核心价值，例如提供一种高效和简化的数据访问方式，以及重视优秀的开发人员体验。出于这个原因，当开发人员将Algolia与GraphQL相结合时，他们会得到一套丰富的工具来构建一流的搜索体验。</p>
<p class="translated">为了了解这两种技术如何协同工作，我们创建了一个虚拟公司，提供在线航班价格比较(flight-tickets.io)。Flight-tickets.io的系统首先利用GraphQL来改进Algolia的后端索引过程，然后它集成了Algolia InstantSearch来提供统一的前端编程环境。</p>
<h2 class="translated"><a id="index-rich-data-into-algolia-with-graphql" class="anchor" href="#index-rich-data-into-algolia-with-graphql" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>用GraphQL将丰富的数据索引成Algolia</h2>
<p class="translated">该公司的Algolia index公布了来自数十家外部供应商的票价。如果没有GraphQL，<a href="https://en.wikipedia.org/wiki/Extract,_transform,_load"> ETL </a>实现将所有提供者的数据编入Algolia索引是复杂的——它需要一个工人处理每个数据源。</p>
<p class="translated">流程是这样的:</p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12907" src="../Images/77e8eab08796c4c18e45854b18405b39.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/09/graphql-search-image3-320x166.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/09/graphql-search-image3-720x374.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/09/graphql-search-image3-768x399.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/09/graphql-search-image3.png 1536w" sizes="(max-width: 623px) 100vw, 623px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/09/graphql-search-image3-320x166.png"/></p>
<p class="translated">如您所见，有三个步骤:从多个提供者获取数据，对其进行转换，然后将其推送到Algolia。随着数据源和API类型(REST、gRPC等)数量的增长，这一过程的复杂性迅速增加，导致工程团队对新提供商的集成和支持速度变慢。</p>
<p class="translated">还有稳定性问题:</p>
<ul>
<li class="translated">每个工作人员必须对每个数据提供者的多个API进行多次调用</li>
<li class="translated">每个提供者都用自己的协议公开数据:REST、gRPC或专有协议</li>
<li class="translated">每个提供者的自定义错误管理都是独特的</li>
</ul>
<h3 class="translated"><a id="adding-graphql-based-indexing" class="anchor" href="#adding-graphql-based-indexing" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>添加基于GraphQL的索引</h3>
<p class="translated">解决方案是通过利用GraphQL重写ETL，如下所示:</p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12906" src="../Images/21bf9b575611a0a626459a2eae6c6b24.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/09/graphql-search-image2-320x166.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/09/graphql-search-image2-720x374.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/09/graphql-search-image2-768x399.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/09/graphql-search-image2.png 1536w" sizes="(max-width: 644px) 100vw, 644px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/09/graphql-search-image2-320x166.png"/></p>
<p class="translated">现在，拉取和转换阶段由一个GraphQL过程管理(或统一)。通过构建一个新的GraphQL内部API，依靠<a href="https://www.graphql-mesh.com/"> GraphQL Mesh </a>，团队在数据提供者和ETL之间添加了一个单一的数据层。</p>
<p class="translated">本质上，ETL从内部GraphQL API提取或订阅数据变更，这公开了以统一方式查询的多个数据源，如下所示:</p>
<pre class="lang:php decode:true ">query getTicketsForProvider($provider: Provider!, $from: Date!, $to: Date!, $cursor: Cursor) {&#13;
  tickets(provider: $provider, from: $from, to: $to, cursor: $cursor) {&#13;
    edges {&#13;
      node {&#13;
        provider {&#13;
          id&#13;
          name&#13;
        }&#13;
        prices {&#13;
          ...PriceByLocationAndTime&#13;
        }&#13;
        # ...&#13;
      }&#13;
      pageInfo {&#13;
        cursor {&#13;
          before&#13;
          after&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
}&#13;
</pre>
<p class="translated">数据是统一的，并且包括错误处理。下面是一个典型的GraphQL错误响应体，包含<code>data</code>和<code>errors</code>字段:</p>
<pre class="lang:json decode:true ">{&#13;
  "data": {&#13;
     “tickets”: []&#13;
  },&#13;
  "errors": [&#13;
    {&#13;
      "message": "[SuperFlight API]: unavailable",&#13;
      "locations": [&#13;
        {&#13;
          "line": 2,&#13;
          "column": 3&#13;
        }&#13;
      ],&#13;
      "extensions": {&#13;
        "code": "TICKETS_GRAPHQL_API_SUPERFLIGHT_ERROR",&#13;
        "exception": {&#13;
          "stacktrace": [&#13;
            "......",&#13;
          ]&#13;
        }&#13;
      }&#13;
    }&#13;
  ]&#13;
}&#13;
</pre>
<p class="translated">最后，除了网络延迟优化，GraphQL还在提供者的数据获取端带来了真正的性能优化。<a href="https://graphql.org/learn/execution/#asynchronous-resolvers"> GraphQL API实现在设计上是高度异步的</a>:每个数据字段都是并行解析的，因此性能更好。</p>
<blockquote><p class="translated"><strong>旁注:</strong> <br/>对于Algolia的Shopify扩展，我们利用Shopify的GraphQL API将Shopify数据索引到Algolia索引中。Shopify的GraphQL API不仅带来了前面已经讨论过的优势，而且更进一步:</p>
<ul>
<li class="translated">与Shopify REST API相比，速率限制更加宽松和灵活</li>
<li class="translated">高级分页模式</li>
</ul>
<p class="translated">从Shopify REST API迁移到Shopify GraphQL API后，我们看到Shopify数据的平均索引速度提高了28%,索引峰值容量提高了150%。</p></blockquote>
<h2 class="translated"><a id="graphql-search-with-instant-search" class="anchor" href="#graphql-search-with-instant-search" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> GraphQL搜索与即时搜索</h2>
<p class="translated">现在他们已经与GraphQL统一了，这家航空公司希望改进他们的搜索UI，使用GraphQL后端搜索来进行SEO和数据丰富，由Algolia提供支持。虽然我们总是建议前端搜索(即直接进入Algolia的服务器以获得最大的瞬时速度)，但在预订机票等预订系统的情况下，明智的做法是额外返回后端服务器以获取实时数据。至于SEO，你可以经常结合前后端来提升你公司的<a href="https://www.algolia.com/blog/ux/google-core-web-vitals-seo-rankings-search-bar-optimization/"> Google SEO </a>。</p>
<h3 class="translated"><a id="algolia-graphql-search" class="anchor" href="#algolia-graphql-search" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Algolia graph QL搜索</h3>
<p class="translated">第一步是在现有的公共GraphQL API上公开一个GraphQL搜索查询。为了实现这一点，后端团队使用了一个名为<a href="https://github.com/charlypoly/algolia-graphql-schema"> <code>algolia-graphql-schema</code> </a>的工具，它从给定的Algolia索引生成GraphQL类型。</p>
<p class="translated"><code>flightsSearch</code> Algolia索引包含如下对象:</p>
<pre class="lang:json decode:true ">{&#13;
  "provider_id": 12312312,&#13;
  "flight_company_name": "Bryan'air",&#13;
  "inbound": "2021-09-13T16:39:22.396Z",&#13;
  "outbound": "2021-19-13T16:39:22.396Z",&#13;
  "price": 1140.00&#13;
  // ...&#13;
}&#13;
</pre>
<p class="translated">他们给<code>package.json</code>添加了以下脚本:</p>
<pre class="lang:json decode:true ">// ...&#13;
"scripts": {&#13;
  "generate:graphql": "algolia-graphql-schema"&#13;
},&#13;
// …&#13;
</pre>
<p class="translated">运行脚本:</p>
<pre class="lang:sh decode:true ">$ npm link&#13;
$ npm run generate:graphql&#13;
&#13;
&gt; algolia-graphql-demo-server@1.0.0 generate:graphql&#13;
&gt; algolia-graphql-schema&#13;
&#13;
Analyzing flightsSearch index (that might take a few seconds...)&#13;
flightsSearch.graphql created!&#13;
</pre>
<p class="translated">生成以下<code>flightsSearch.graphql</code>:</p>
<pre class="lang:php decode:true">type AlgoliaResultObject {&#13;
  provider_id: String!&#13;
  flight_company_name: String!&#13;
  inbound: Date!&#13;
  outbound: Date!&#13;
  price: Int!&#13;
  # ...&#13;
}&#13;
&#13;
type SearchResultsEdge {&#13;
  cursor: Int!&#13;
  node: AlgoliaResultObject&#13;
}&#13;
&#13;
type SearchResults {&#13;
  edges: [SearchResultsEdge!]!&#13;
  totalCount: Int!&#13;
}&#13;
&#13;
input SearchInput {&#13;
  query: String&#13;
  similarQuery: String&#13;
  sumOrFiltersScores: Boolean&#13;
  filters: String&#13;
  page: Int&#13;
  hitsPerPage: Int&#13;
  offset: Int&#13;
  length: Int&#13;
  attributesToHighlight: [String]&#13;
  attributesToSnippet: [String]&#13;
  attributesToRetrieve: [String]&#13;
  # ...&#13;
}&#13;
&#13;
type Query {&#13;
  # ...&#13;
  search_flights($input: SearchInput!, $after: String): [SearchResults!]!&#13;
}&#13;
</pre>
<p class="translated">一旦他们将生成的搜索类型定义集成到现有的GraphQL API类型中，并且<a href="https://graphql.org/learn/execution/#root-fields-resolvers">实现了调用Algolia搜索API的相应解析器</a>，后端团队就为前端团队使用Algolia InstantSearch构建新的搜索UI开了绿灯。</p>
<h3 class="translated"><a id="algolia-instantsearch-graphql-integration" class="anchor" href="#algolia-instantsearch-graphql-integration" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Algolia instant search graph QL集成</h3>
<p class="translated">前端团队现在能够使用<code>search_flights($input: SearchInput!, $after: String)</code> GraphQL查询来搜索机票。幸运的是，Algolia已经记录了<a href="https://www.algolia.com/doc/guides/building-search-ui/going-further/backend-search/in-depth/backend-instantsearch/js/#searching-for-results">如何在后端</a>使用InstantSearch，所以设置很快。</p>
<p class="translated">前端团队为他们的InstantSearch实现了一个定制的GraphQL搜索客户端。</p>
<pre class="lang:javascript decode:true ">import { SearchClient } from 'instantsearch.js'&#13;
&#13;
const query = `&#13;
  Search($input: SearchInput!, $after: String) {&#13;
    search_flights(input: $input, before: $after) {&#13;
      edges {&#13;
        cursor&#13;
        node {&#13;
          provider_id&#13;
          flight_company_name&#13;
          inbound&#13;
          outbound&#13;
          price&#13;
          # ...&#13;
&#13;
        }&#13;
      }&#13;
      totalCount&#13;
    }&#13;
  }&#13;
`;&#13;
&#13;
const HITS_PER_PAGE = 20&#13;
&#13;
const transformResponse = ({ query, page }) =&gt; (response) =&gt;&#13;
  response.data?.search_flights.edges.reduce(&#13;
    (acc, edge) =&gt; {&#13;
      acc.results[0].hits.push(edge.nodes);&#13;
      acc.results[0].nbHits += 1&#13;
    },&#13;
    {&#13;
      results: [&#13;
        {&#13;
            hits: [],&#13;
            page,&#13;
            nbHits: response.data?.search_flights.edges.length || 0,&#13;
            nbPages: response.data?.search_flights.totalCount / HITS_PER_PAGE,&#13;
            query: query || "",&#13;
            exhaustiveNbHits: false,&#13;
            hitsPerPage: HITS_PER_PAGE,&#13;
            processingTimeMS: 0,&#13;
            params: ""&#13;
          }&#13;
      ],&#13;
    }&#13;
  );&#13;
&#13;
const searchClient: SearchClient = {&#13;
  searchForFacetValues: (() =&gt; {}) as any,&#13;
  search(requests) {&#13;
    const request = requests[0]&#13;
    return fetch("https://api.flightickets.io/graphql", {&#13;
      method: "post",&#13;
      headers: {&#13;
        "Content-Type": "application/json",&#13;
      },&#13;
      body: JSON.stringify({&#13;
        query,&#13;
        variables: { input: { ...request } },&#13;
      }),&#13;
    }).then(transformResponse({ query: request.query, page: request.page }));&#13;
  },&#13;
};&#13;
&#13;
</pre>
<p class="translated">注意:搜索UI代码通过GraphQL API以单个Algolia索引为目标。</p>
<p class="translated">定制的<code>hits</code>小部件受益于GraphQL搜索API生成的TypeScript搜索结果类型，如下所示:</p>
<pre class="lang:javascript decode:true ">// TypeScript types generated from the GraphQL API using GraphQL code generator&#13;
import { AlgoliaResultObject } from './graphql/generated'&#13;
&#13;
const structuredResults = connectHits(({ hits, widgetParams }) =&gt; {&#13;
  const results = hits as AlgoliaResultObject[];&#13;
  // results.flight_company_name is autocompleted by TypeScript generated types&#13;
&#13;
  const { container } = widgetParams;&#13;
&#13;
  if (&#13;
    results&#13;
  ) {&#13;
    // Render the result&#13;
    // ...&#13;
    return;&#13;
  }&#13;
&#13;
  // Render no results&#13;
  // ...&#13;
});&#13;
</pre>
<p class="translated">他们准备好出发了。他们只需要将Algolia集成到GraphQL API以及前端的即时搜索配置中:</p>
<ul>
<li class="translated">在API端，他们需要用JavaScript客户端调用Algolia</li>
<li class="translated">在即时搜索端，他们需要向即时搜索提供<code>searchClient</code>和一个定制的<code>hits</code>小部件</li>
</ul>
<h2 class="translated"><a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>结论</h2>
<p class="translated">通过结合Algolia和GraphQL，flight-tickets.io改善了他们的整体用户和开发者体验。</p>
<p class="translated">首先，通过构建一个更快、更稳定、更丰富的索引管道，利用GraphQL来消费和统一来自数十个提供商的数据:</p>
<ul>
<li class="translated">独特的数据语言和错误管理</li>
<li class="translated">GraphQL并行架构带来了一些性能提升</li>
<li class="translated">降低复杂性，改善开发人员体验</li>
</ul>
<p class="translated">最后，通过利用GraphQL和构建后端搜索，前端团队使用Algolia InstantSearch将搜索完美地集成到前端堆栈中。</p>
<p class="translated">对这篇文章有任何反馈吗？我很想收到你的来信:<a href="https://twitter.com/whereischarly">@ where is chary</a></p>
</div></div>    
</body>
</html>