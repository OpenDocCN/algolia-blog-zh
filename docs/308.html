<html>
<head>
<title>How to implement autocomplete with JavaScript on your website - Algolia Blog | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在你的网站上用JavaScript实现自动完成</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/how-to-implement-autocomplete-with-javascript-on-your-website/#0001-01-01">https://www.algolia.com/blog/engineering/how-to-implement-autocomplete-with-javascript-on-your-website/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="translated">你以前可能见过自动完成搜索，用户在键入时会得到建议的搜索。它不仅为你的用户节省了击键和时间，还可以发现他们可能没有发现的潜在结果。</p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12326" src="../Images/f02d706f506db1fba2285e2cfb9979b2.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-2-320x153.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-2-720x343.png 720w, https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-2-768x366.png 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-2-1536x732.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-2.png 1598w" sizes="(max-width: 454px) 100vw, 454px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-2-320x153.png"/></p>
<p class="translated"><span>例如，如果有人在你的产品目录搜索中输入“苹果”,他们会在输入时得到各种建议。为了提供匹配，您需要从某个地方获取这些潜在的结果——数据库、API或已知术语列表。</span></p>
<p class="translated"><span>在深入构建您自己的自动完成功能之前，让我们来看看一个健壮的产品级解决方案:</span></p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12459" src="../Images/d9c4d0d321eaba68f68edc6042a013fc.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/github.com_algolia_autocomplete-230x178.jpg 230w, https://blog-api.algolia.com/wp-content/uploads/2021/07/github.com_algolia_autocomplete-516x400.jpg 516w, https://blog-api.algolia.com/wp-content/uploads/2021/07/github.com_algolia_autocomplete-768x595.jpg 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/github.com_algolia_autocomplete.jpg 1200w" sizes="(max-width: 569px) 100vw, 569px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/github.com_algolia_autocomplete-230x178.jpg"/></p>
<p class="translated"><span>我们已经写了这个<a href="https://www.algolia.com/blog/ux/replicating-the-algolia-documentation-search-with-autocomplete/">自动完成解决方案</a>，它可以将简单的下拉转换成<a href="https://www.algolia.com/blog/ux/taking-documentation-search-to-new-heights-with-algolia-and-autocomplete/">丰富和多面的交互式用户体验。</a>当今天的用户开始输入查询时，他们希望看到的不仅仅是建议的查询，他们希望访问各种数据源和结果、多种过滤器、类别以及带有有用和高亮文本的图像。</span></p>
<p class="translated"><span>这个<a href="https://github.com/algolia/autocomplete">自动完成库是开源的</a>，完全可以为任何行业和UI/UX设计定制。</span></p>
<p class="translated"><span>在本文中，我们后退一步，向您展示如何用Javascript构建一个简单的自动完成功能，以帮助您理解我们更具产品级版本的原理。我们还将展示，为了正确地调优您的自动完成搜索，您将需要使用额外的前端和后端代码来完成繁重的工作。</span></p>
<blockquote><p class="translated">相关链接–</p>
<ol>
<li class="translated">查看所有<a href="https://www.algolia.com/developers/implement-search-autocomplete/">可能的自动完成体验</a>。</li>
<li class="translated">自动完成的全面的<a href="https://www.algolia.com/doc/ui-libraries/autocomplete/introduction/getting-started/">“入门”指南</a>。</li>
<li class="translated">解释如何将自动完成与即时搜索JS 集成的指南。</li>
</ol>
</blockquote>
<h2 class="translated"><a id="basic-implementation-using-static-data" class="anchor" href="#basic-implementation-using-static-data" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>基本实现使用静态数据</span></h2>
<p class="translated"><span>首先，让我们创建一个概念验证自动完成示例。我们的目标是允许用户开始在搜索框中键入内容，并在搜索表单下方看到匹配的术语— <em>在用户输入到搜索栏时自动完成</em>用户的输入。</span></p>
<p class="translated"><span>任何JavaScript自动完成搜索都需要以下内容:</span></p>
<ul>
<li class="translated"><span>搜索表单的HTML</span></li>
<li class="translated"><span> CSS显示结果</span></li>
<li class="translated"><span>结果的数据来源</span></li>
<li class="translated"><span>当然是JavaScript</span></li>
</ul>
<p class="translated"><span>由于我们从一个基本的实现开始，我们将从一组预先确定的搜索词中返回精确的匹配结果。我们将使用一个在线商店作为我们的例子，其中用户正在搜索一个特定的项目。如果他们在搜索框中输入的内容可以与某个项目匹配，网站会推荐该项目。</span></p>
<p class="translated">让我们看看这个搜索框在一些简单的HTML中是什么样子的</p>
<pre class="lang:html decode:true ">&lt;form autocomplete="off"&gt;&lt;input type="text" name="q" id="q" <span>onKeyUp</span>="showResults(this.value)" /&gt;&#13;
&lt;div id="result"&gt;&lt;/div&gt;&#13;
&lt;/form&gt;&#13;
</pre>
<p class="translated">禁用autocomplete ( <code>autocomplete = off</code>)可能看起来有点奇怪，但这是为了禁用浏览器的自动建议，它会妨碍我们自己。</p>
<p class="translated"><span>其他一些需要注意的事情是<code>onKeyUp</code>属性，它调用我们的JavaScript函数，并使用一个空的<code>div</code>作为结果。</span></p>
<p class="translated"><span>接下来，这里是接收搜索值的JavaScript，将它与已知的术语进行匹配，并显示建议:</span></p>
<pre class="lang:js decode:true ">var search_terms = ['apple', 'apple watch', 'apple macbook', 'apple macbook pro', 'iphone', 'iphone 12'];&#13;
&#13;
function autocompleteMatch(input) {&#13;
  if (input == '') {&#13;
    return [];&#13;
  }&#13;
  var reg = new RegExp(input)&#13;
  return search_terms.filter(function(term) {&#13;
	  if (term.match(reg)) {&#13;
  	  return term;&#13;
	  }&#13;
  });&#13;
}&#13;
&#13;
function showResults(val) {&#13;
  res = document.getElementById("result");&#13;
  res.innerHTML = '';&#13;
  let list = '';&#13;
  let terms = autocompleteMatch(val);&#13;
  for (i=0; i&lt;terms.length; i++) {&#13;
    list += '&lt;li&gt;' + terms[i] + '&lt;/li&gt;';&#13;
  }&#13;
  res.innerHTML = '&lt;ul&gt;' + list + '&lt;/ul&gt;';&#13;
}&#13;
</pre>
<p class="translated"><span>这些术语作为一个简单的JavaScript数组存储在顶部。每次按键后，浏览器都会调用<code>showResults</code>函数。然后，它将当前搜索传递给一个<code>autocompleteMatch</code>函数，以获取匹配项的列表。最后，结果作为无序列表添加到<code>div</code>中。</span></p>
<p class="translated"><span>当您运行这段代码时，您会注意到匹配的术语作为项目符号出现在搜索框下方。这并不是一次很好的经历。我们更希望看到这样的东西:</span></p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12345" src="../Images/2860daa3cd5cde883b42c0010cc6db84.png" alt="" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-3-2.png"/></p>
<p class="translated"><span>一个小小的CSS就可以完成这个风格，你可以定制它来匹配你的站点:</span></p>
<pre class="lang:css decode:true ">#result {&#13;
  border: 1px dotted #ccc;&#13;
  padding: 3px;&#13;
}&#13;
#result ul {&#13;
  list-style-type: none;&#13;
  padding: 0;&#13;
  margin: 0;&#13;
}&#13;
#result ul li {&#13;
  padding: 5px 0;&#13;
}&#13;
#result ul li:hover {&#13;
  background: #eee;&#13;
}&#13;
</pre>
<p class="translated"><span>虽然我们现在已经有了一个JavaScript实现的基本自动完成功能，但它还远远不能用于生产。首先，数据来自单个静态数组，硬编码在我们的JavaScript中。让我们通过合并一个后端搜索请求向一个更现实的例子迈进一步。</span></p>
<h2 class="translated"><a id="back-end-driven-autocomplete-with-an-internal-api" class="anchor" href="#back-end-driven-autocomplete-with-an-internal-api" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>后端驱动:用内部API自动完成</span></h2>
<p class="translated">JavaScript的基本自动完成示例显示了用户期望的大多数交互模式。总有一些设计和交互方面的改进需要考虑，但概念依然存在:当用户在搜索栏中键入几个键时，他们会在下面看到相关的潜在搜索或结果。不同之处——也是这篇文章剩余部分的主题——是我们在哪里检索这些结果的<em>。</em></p>
<p class="translated">在大多数足够复杂的例子中，你不会有一个有限的潜在查询列表。第一部分中的静态实现是一个概念验证，不会在生产中应用。您需要将您的搜索发送到后端以返回潜在的匹配，这意味着需要一个内部API来处理查询。</p>
<p class="translated"><span>我们可以更新上一节中的<code>showResults</code>函数，如下所示:</span></p>
<pre class="lang:javascript decode:true ">function showResults(val) {&#13;
  res = document.getElementById("result");&#13;
  res.innerHTML = '';&#13;
  if (val == '') {&#13;
    return;&#13;
  }&#13;
  let list = '';&#13;
  fetch('/suggest?q=' + val).then(&#13;
   function (response) {&#13;
     return response.json();&#13;
   }).then(function (data) {&#13;
     for (i=0; i&lt;data.length; i++) {&#13;
       list += '&lt;li&gt;' + data[i] + '&lt;/li&gt;';&#13;
     }&#13;
     res.innerHTML = '&lt;ul&gt;' + list + '&lt;/ul&gt;';&#13;
     return true;&#13;
   }).catch(function (err) {&#13;
     console.warn('Something went wrong.', err);&#13;
     return false;&#13;
   });&#13;
}&#13;
</pre>
<p class="translated"><span>我们在<code>/suggest</code>调用本地API端点，而不是用<code>autocompleteMatch</code>函数将当前搜索与潜在查询进行比较。这将返回一个潜在匹配的JSON数组。</span></p>
<p class="translated"><span>为了测试这一点，你可以用Node或任何其他后端语言建立自己的本地API。例如，下面的<code>Express</code>路由将为传递给<code>q</code>查询字符串的任何内容提供建议:</span></p>
<pre class="lang:javascript decode:true ">var express = require('express');&#13;
var router = express.Router();&#13;
&#13;
const data = ["apple","apple watch","iphone","iphone x","apple macbook","apple macbook air","apple macbook air pro 13"];&#13;
&#13;
router.get('/suggest', function(req, res, next) {&#13;
  console.log(req.query)&#13;
  res.setHeader('Content-Type', 'application/json');&#13;
  res.end(JSON.stringify(data.filter(value =&gt; value.includes(req.query.q))));&#13;
});&#13;
&#13;
module.exports = router;&#13;
</pre>
<p class="translated"><span>注意，如果我们将它部署到服务器上，我们可能会看到性能影响。每次查找都发生在一次按键之后，这在用户输入多次按键时可能没有意义。在通过互联网连接到后端之前，您需要在前端加入一个延迟，比如网络节流。</span></p>
<h2 class="translated"><a id="adding-a-query-suggestions-database" class="anchor" href="#adding-a-query-suggestions-database" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>添加查询建议数据库</span></h2>
<p class="translated"><span>该代码具有我们之前使用的相同的有限术语数据集。我们还在做原型。您需要将后端API连接到数据库。当每个调用都包含一个往返HTTP调用时，查询延迟会变得更加重要，HTTP调用本身会调用数据库。</span></p>
<p class="translated">好处是显而易见的:通过访问数据库，你可以在用户输入时提出一组与他们的字符相匹配的查询建议。 <a href="https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/query-suggestions/how-to/creating-a-query-suggestions-index/js/"> <span>查询建议</span> </a> <span>数据库包含搜索引擎在处理每个查询时保存的先前查询。这些查询通常按受欢迎程度排序。谷歌提供了一个例子:</span></p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12331" src="../Images/e4345c0b6dc357c1fff36659ee60c446.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/qs-example-5053ff84-1-2-278x178.jpeg 278w, https://blog-api.algolia.com/wp-content/uploads/2021/07/qs-example-5053ff84-1-2-624x400.jpeg 624w, https://blog-api.algolia.com/wp-content/uploads/2021/07/qs-example-5053ff84-1-2-768x493.jpeg 768w, https://blog-api.algolia.com/wp-content/uploads/2021/07/qs-example-5053ff84-1-2.jpeg 998w" sizes="(max-width: 553px) 100vw, 553px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/qs-example-5053ff84-1-2-278x178.jpeg"/></p>
<p class="translated">你的数据库需要考虑很多因素。是专门为搜索词打造的吗？或者您是否需要连接到一个现有的源，比如一个产品或内容数据库？您将如何针对这些频繁、简短的查询进行调整？</p>
<p class="translated"><span>这些都是大问题，很可能指向从多个来源获取结果的需求，一个叫做</span> <i> <span>联合搜索</span> </i> <span>的概念。</span></p>
<h2 class="translated"><a id="federated-search-query-multiple-dynamic-data-sources" class="anchor" href="#federated-search-query-multiple-dynamic-data-sources" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>联合搜索:查询多个动态数据源</span></h2>
<p class="translated">你用过的大多数搜索引擎很可能来自不止一个数据库。与基本的autocomplete示例不同，它们不具备小型静态潜在搜索集的优势。如果您担心对单个数据库的性能影响，那么使用<a href="https://www.algolia.com/blog/ux/what-is-federated-search/">联合搜索会更加困难。</a> </p>
<p class="translated">你不仅有多个来源，而且每个来源都是动态的。产品数据库可能每晚更新，而库存管理系统旨在实时更新。你的评论可能存储在其他地方，每天发布几次。您可能希望更快地获得评论以引发讨论。</p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12346" src="../Images/7c0145f1333fe7f9cf8eca8c5f701a4e.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-4-1-320x85.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-4-1.png 420w" sizes="(max-width: 616px) 100vw, 616px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-4-1-320x85.png"/></p>
<p class="translated">这些数据库中的每一个都有你可能想要搜索的字段，而其他的则不需要。显然需要包括产品名称、描述和元数据。但是内部标识符或产品代码可能不是必需的。类似地，用户生成的内容可以提供丰富的搜索词，但您需要确保个人信息，如电子邮件或IP地址，不会出现在搜索建议中。</p>
<p class="translated"><span>一旦您决定了在您的联邦搜索中使用哪些<a href="https://www.algolia.com/blog/product/make-disorganized-content-discoverable/">数据源，您需要确保它可以通过一次调用从前端到达，如后端驱动的自动完成部分所示。换句话说，您可能不希望前端在每次击键后直接调用多个数据源——这不仅效率低下，而且可能会暴露过多的内部数据模型。相反，您可能会使用两种架构中的一种:</a></span></p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12347" src="../Images/9c692361280ff72098064438f2f29d83.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-5-1-320x170.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-5-1.png 459w" sizes="(max-width: 542px) 100vw, 542px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-5-1-320x170.png"/></p>
<p class="translated"><span>左图显示了您的前端如何调用一个后端API，该API本身向您的数据库发出多个请求。它需要将这些响应合并和过滤成一组搜索建议或结果，供前端显示。</span></p>
<p class="translated"><span>或者，右边显示一个专用的搜索数据库，供单个地方查询。您需要根据其他来源定期更新这个数据库。与其他架构的不同之处在于，结果的合并和过滤是提前进行的。在许多情况下，搜索不需要像直接查找那样实时。例如，用户可能希望一条评论立即出现在页面上，但不会注意到它是否需要一个小时或更长时间才能出现在搜索中。</span></p>
<p class="translated">对于如何合并和过滤联合搜索结果，有许多不同的方法。为了给搜索者提供最好的用户体验，你可能需要考虑一些额外的方法来调整你的搜索结果。</p>
<h2 class="translated"><a id="beyond-autocomplete-what-robust-search-requires" class="anchor" href="#beyond-autocomplete-what-robust-search-requires" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>超越自动完成:健壮搜索需要什么</span></h2>
<p class="translated">实现伟大的自动完成功能不仅仅是知道JavaScript、HTML和CSS的正确组合。您需要访问正确的数据源，并从后端提供结果，以便您的前端能够轻松地将结果显示给用户。此外，你会发现，你越是考虑什么是可能的，潜在的改进就会越多。</p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-12348" src="../Images/eec2a0c8fd590ba2dee7f2e5bf4f9afa.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-6-1-320x154.png 320w, https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-6-1.png 587w" sizes="(max-width: 596px) 100vw, 596px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2021/07/pasted-image-0-6-1-320x154.png"/></p>
<p class="translated"><span>例如，在上面的搜索建议中有一些需要注意的事情:</span></p>
<ol>
<li class="translated"><span>虽然“iphone”被拼错了，但结果会灵活地假设用户的意思</span></li>
<li class="translated"><span>对于某些术语，用户可以按类别进行更具体的搜索</span></li>
</ol>
<p class="translated"><span>这两个特性都需要一些额外的工程来实现。您的数据库可能支持针对拼写错误的模糊搜索，尽管您需要确保模糊搜索的实现不会降低性能。考虑到这一点，我们实现了一个不会降低查询速度的</span> <a href="https://www.algolia.com/doc/guides/managing-results/optimize-search-results/typo-tolerance/"> <span>错别字容差</span> </a> <span>特性。</span></p>
<p class="translated"><span>类别搜索更高级，需要搜索数据库中的额外结构。我们已经写了一个关于带有JSON属性 </span> <span>的<a href="https://www.algolia.com/blog/engineering/facets-and-faceted-search-making-every-attribute-count/">刻面搜索的指南，讨论了如何为这种类型的过滤搜索组织数据。</a></span></p>
<p class="translated">如果你想构建健壮的搜索，Algolia可以支持你。<a href="https://www.algolia.com/products/search-and-discovery/search-autocomplete/">搜索建议和方面</a>内置于我们的<a href="https://www.algolia.com/products/search-and-discovery/hosted-search-api/"> API驱动平台</a>  <span>。</span></p>
<p> </p>
<blockquote>
<p class="translated">相关链接–</p>
<ol>
<li class="translated">查看所有<a href="https://www.algolia.com/developers/implement-search-autocomplete/">可能的自动完成体验</a>。</li>
<li class="translated">自动完成的综合<a href="https://www.algolia.com/doc/ui-libraries/autocomplete/introduction/getting-started/">“入门”指南</a>。</li>
<li class="translated">解释如何将自动完成与即时搜索集成的指南。</li>
</ol>
</blockquote>
</div></div>    
</body>
</html>