<html>
<head>
<title>Adding trending recommendations to your existing e-commerce store - Algolia Blog | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向您现有的电子商务商店添加趋势推荐- Algolia博客</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/adding-trending-recommendations-to-your-existing-e-commerce-store/#0001-01-01">https://www.algolia.com/blog/engineering/adding-trending-recommendations-to-your-existing-e-commerce-store/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="translated">推荐可以成就或毁掉一次网上购物体验。在一个充满无限选择和无限滚动的世界里，推荐让客户能够穿过噪音，发现他们更有可能喜欢的新东西。他们还可以帮助客户了解新的购物领域的新事物——无论是搜索完美的礼物还是购买新的东西，基于推荐的功能，如趋势产品部分，可以帮助用户充分利用他们的在线时间。</p>
<p class="translated">对于希望将这些重要功能添加到他们的电子商务体验中的开发者来说，<a href="https://www.algolia.com/doc/guides/algolia-recommend/overview/"> Algolia推荐</a>可以成为拯救世界的超级英雄。请继续阅读，了解如何利用Algolia推荐以及Insights API来展示趋势产品并增强您的电子商务应用程序！</p>
<h2 class="translated"><a id="what-we%e2%80%99re-building" class="anchor" href="#what-we%e2%80%99re-building" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>我们在建设什么</h2>
<p class="translated">在本文中，我们将使用React和Commerce.js开发一个电子商务应用程序。幸运的是，我们不必从头开始构建——我们将使用最初为Algolia DevCon 开发的<a href="https://github.com/hello-ashleyintech/algolia-commercejs-app">这个</a>基本电子商务应用程序<a href="https://www.youtube.com/watch?v=61r_YZn5x84&amp;ab_channel=Algolia">作为我们的起点。</a></p>
<p class="translated">完成教程后，我们的应用程序将能够使用Algolia的InstantSearch insights库、Insights API和Algolia Recommend在单个产品详情页面上推荐热门产品。</p>
<p class="translated">如果你想提前查看完整的项目代码，可以访问<code>[algolia-commercejs-recommendations-app</code>资源库】(https://github . com/hello-ashleyintech/algolia-commerce js-recommendations-app)。</p>
<p class="translated"><img src="../Images/e8c43c4c849ca5a351aaa629dae36877.png" alt="rec-only-algolia-commercejs-recommendations-app.gif" data-original-src="https://www.algolia.com/blog/engineering/adding-trending-recommendations-to-your-existing-e-commerce-store/Adding%20trending%20recommendations%20to%20your%20existing%20e%20f698db1899ef402cb0e896d4142debef/rec-only-algolia-commercejs-recommendations-app.gif"/></p>
<p class="translated"><img loading="lazy" class="alignnone size-full wp-image-18191" src="../Images/8184d55fc89121e7f29bbedbaca5b776.png" alt="" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2023/02/rec-only-algolia-commercejs-recommendations-app.gif"/></p>
<p class="translated">还要记住，尽管这篇文章是面向React和Commerce.js的，但它仍然是扩展任何带有Algolia推荐的<em>电子商务应用程序的通用指南。如果您对在不同的环境中实施推荐有更具体的问题，<a href="https://www.algolia.com/doc/guides/algolia-recommend/overview/">文档</a>会提供您想要的信息。</em></p>
<h2 class="translated"><a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>入门</h2>
<p class="translated">在我们开始构建之前，请确保您设置了以下内容:</p>
<ul>
<li class="translated"><em> Node: </em>要检查是否已经安装了Node，可以在命令行中运行<code>node -v</code>。如果没有弹出版本，你需要安装它——你可以在这里找到你的机器<a href="https://nodejs.org/en/download/">的安装说明。</a></li>
<li class="translated">Chec:  Commerce.js使用一个名为Chec的平台来管理您的集成、API密钥和产品。你需要在这里创建一个账户<a href="https://commercejs.com/">，然后建立一个Commerce.js商店。</a></li>
<li class="translated"><em> Algolia: </em>要利用Algolia的功能，你需要在这里创建一个Algolia账户<a href="https://www.algolia.com/users/sign_up">。您还需要</a><a href="https://support.algolia.com/hc/en-us/articles/4406975239441-How-do-I-create-an-application-">创建一个应用程序</a>来表示您的电子商务应用程序，然后创建一个名为<code>products</code>的<a href="https://support.algolia.com/hc/en-us/articles/4406981910289-What-is-an-index-">索引</a>。</li>
<li class="translated"><em> ngrok: </em>在这里创建一个ngrok账户<a href="https://ngrok.com/signup">。您将需要它从您的本地应用程序隧道连接，以便您可以配置webhooks和进行API调用。</a></li>
</ul>
<p class="translated">当以上一切准备就绪时，将基础项目<a href="https://github.com/hello-ashleyintech/algolia-commercejs-app"> <code>algolia-commercejs-app</code>的GitHub库</a>克隆到您的机器上。然后，按照本自述文件中的说明<a href="https://github.com/hello-ashleyintech/algolia-commercejs-recommendations-app#readme">完成本教程应用程序的设置(确保为<code>client</code>和<code>server</code>目录在<code>.env.example</code>中设置了包含所有环境变量的<code>.env</code>文件)。</a></p>
<p class="translated">一旦您有了一个在本地运行的电子商务商店，并且成功地展示了您的产品并运行了聊天机器人，您就可以进行下一步了！</p>
<p> </p>
<p class="translated"><img loading="lazy" class="alignnone size-full wp-image-18192" src="../Images/c6661e545f0d2c0ff720f3099cc1b64c.png" alt="" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2023/02/186823255-01cb05fb-bfc3-462c-a76c-3b0bfa269f52.gif"/></p>
<h2 class="translated"><a id="let%e2%80%99s-build" class="anchor" href="#let%e2%80%99s-build" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>咱们建吧！</h2>
<p class="translated">既然基础应用程序已经设置好了，让我们开始构建吧！🔨</p>
<h3 class="translated"><a id="add-in-routing-and-a-product-detail-page" class="anchor" href="#add-in-routing-and-a-product-detail-page" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>在工艺路线和产品明细页面中添加</h3>
<p class="translated">为了开始跟踪什么是趋势，我们需要设置页面路由和一个组件，当从主屏幕上单击产品时，它会显示产品的详细信息页面。</p>
<p class="translated"><img loading="lazy" class="alignnone size-full wp-image-18189" src="../Images/79a8933ec8f4deaaf5fe74cecc431283.png" alt="" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2023/02/algolia-recommend-product-detail-demo-1.gif"/></p>
<h3 class="translated"><a id="create-a-productindividual-component" class="anchor" href="#create-a-productindividual-component" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>创建<code>ProductIndividual</code>组件</h3>
<p class="translated">首先，我们需要一个新的组件来展现产品的细节。在您选择的代码编辑器中，通过向<code>client/src/components</code>目录添加一个新文件<code>ProductIndividual.js</code>，创建一个新组件<code>ProductIndividual</code>:</p>
<pre><code class="language-jsx">// client/src/components/ProductIndividual.js&#13;
import React from "react";&#13;
&#13;
function ProductIndividual() {&#13;
  return (&#13;
    &lt;&gt;&lt;/&gt;&#13;
  );&#13;
}&#13;
&#13;
export default ProductIndividual;&#13;
</code></pre>
<p class="translated">您可能会注意到文件现在非常空——组件将是空的，直到我们能够从<code>ProductList</code>向其传递单个产品数据。一旦我们配置了主页和产品详细信息页面之间的链接路径，这将成为可能。</p>
<p class="translated">在<code>client/src/components</code>目录中，还可以为标题为<code>ProductIndividual.css</code>的<code>ProductIndividual</code>组件创建一个对应的CSS文件。因为组件中没有呈现任何内容，所以这个CSS文件现在可以保留为空白。您可以通过在现有的import语句下添加以下行，在您的<code>ProductIndividual.js</code>文件中导入新的CSS文件:</p>
<pre><code class="language-jsx">import "./ProductIndividual.css";&#13;
</code></pre>
<h3 class="translated"><a id="set-up-react-router" class="anchor" href="#set-up-react-router" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>设置React路由器</h3>
<p class="translated">为了路由到不同的页面，我们将使用<a href="https://reactrouter.com/en/main"> React Router </a>，它允许我们无缝地创建具有不同视图的URL路由。首先，我们需要安装<code>react-router-dom</code>包。在项目的<code>client</code>目录中运行以下命令，以便只在前端安装软件包:</p>
<pre><code class="language-bash">npm i react-router-dom&#13;
</code></pre>
<p class="translated">一旦安装了这个包，我们就可以开始向我们的应用程序添加路由，包括一个指向我们刚刚添加的<code>ProductIndividual</code>组件的路由。为此，转到<code>client/src/App.js</code>并将以下导入语句添加到文件顶部:</p>
<pre><code class="language-jsx">import { BrowserRouter as Router, Routes, Route } from "react-router-dom";&#13;
import ProductIndividual from "./components/ProductIndividual";&#13;
</code></pre>
<p class="translated">既然已经导入了<code>react-router-dom</code>,我们可以使用它的功能将URL路由连接到由各种组件组成的不同视图。在<code>App()</code>函数中，更新<code>return()</code>，使其仅包含以下代码:</p>
<pre><code class="language-jsx">&lt;Router&gt;&#13;
  &lt;div className="app"&gt;&#13;
    &lt;NavBar /&gt;&#13;
    &lt;Routes&gt;&#13;
      &lt;Route&#13;
        exact path="/"&#13;
        element={&#13;
          &lt;&gt;&#13;
            &lt;ProductsList products={products} /&gt;&#13;
            &lt;Bot /&gt;&#13;
          &lt;/&gt;&#13;
        }&#13;
      /&gt;&#13;
      &lt;Route&#13;
        exact path="/products/:id"&#13;
        element={&#13;
          &lt;&gt;&#13;
            &lt;ProductIndividual /&gt;&#13;
            &lt;Bot /&gt;&#13;
          &lt;/&gt;&#13;
        }&#13;
      /&gt;&#13;
    &lt;/Routes&gt;&#13;
  &lt;/div&gt;&#13;
&lt;/Router&gt;&#13;
</code></pre>
<p class="translated">上面的代码初始化了两条路线，<code>/</code>和<code>/products/:id</code>:</p>
<ul>
<li class="translated"><code>/</code>路径呈现了用户可用的所有产品的主页视图，以及基础应用程序中存在的聊天机器人小部件。</li>
<li class="translated"><code>/products/:id</code>路径将呈现新添加的<code>ProductIndividual</code>组件以及基础应用程序中已有的聊天机器人小部件。此路线中的<code>:id</code>代表所选产品的ID，它允许在所有不同的产品详细信息页面中区分路线。</li>
</ul>
<h3 class="translated"><a id="make-navbar-icon-clickable" class="anchor" href="#make-navbar-icon-clickable" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>使导航栏图标可点击</h3>
<p class="translated">既然我们已经设置了路线，我们可以在导航栏中配置我们的品牌图标，以链接回主页。这对于我们进入产品详细信息页面非常有用，因为它会给我们一个简单的返回主页的路径。</p>
<p class="translated">转到<code>client/src/components/NavBar.js</code>并添加以下导入语句:</p>
<pre><code class="language-jsx">import { Link } from "react-router-dom";&#13;
</code></pre>
<p class="translated">这将从<code>react-router-dom</code>包中导入一个<code>Link</code>组件。<code>[Link</code>组件】(https://reactrouter . com/en/main/components/link)允许我们将组件、文本和其他元素链接到<code>App.js</code>中React Router初始化的路由。</p>
<p class="translated">为了使logo组件<code>&lt;Logo&gt;</code>在导航条中可链接，你应该把它包装在<code>&lt;Link&gt;</code>标签中，就像这样:</p>
<pre><code class="language-jsx">&lt;Link to={"/"}&gt;&#13;
  &lt;Logo className="logo" /&gt;&#13;
&lt;/Link&gt;&#13;
</code></pre>
<p class="translated">我们将一个<code>to</code>属性传递给<code>Link</code>组件，该属性将指定当点击<code>&lt;Link&gt;</code>标签中的组件时，应用程序将重定向到什么路由。在这种情况下，<code>to</code>属性是到主页的路径(<code>/</code>)。</p>
<p class="translated">一旦添加完毕，点击你的导航条图标，你将回到主页！</p>
<h2 class="translated"><a id="set-up-home-page-products-to-link-to-product-details" class="anchor" href="#set-up-home-page-products-to-link-to-product-details" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>设置商品首页链接到商品详情</h2>
<p class="translated">现在我们已经有了链接组件的经验，这样它们可以重定向到特定的路径，我们可以开始工作，使主页上的每个产品都可以点击！</p>
<p class="translated">主页上的每个产品都是通过<code>ProductsList</code>组件呈现的，从Commerce.js查询的一组产品已经作为一个道具传入。在<code>ProductsList</code>组件中，产品数组被遍历以呈现显示每个产品及其相关信息的单个<code>ProductItem</code>组件。</p>
<p class="translated">在<code>ProductsList</code>中，我们可以将为每个产品呈现的<code>ProductItem</code>包装在一个<code>&lt;Link&gt;</code>标签中，这样产品就可以导航到单个产品页面。</p>
<p class="translated">首先，在<code>client/src/components/ProductsList.js</code>中导入<code>Link</code>组件:</p>
<pre><code class="language-jsx">import { Link } from "react-router-dom";&#13;
</code></pre>
<p class="translated">然后，在同一个文件中，将在<code>products.map()</code>语句的每次迭代中呈现的<code>ProductItem</code>组件包装在一个<code>&lt;Link&gt;</code>标记中:</p>
<pre><code class="language-jsx">&lt;Link&#13;
    to={`/products/${product.id}`}&#13;
    state={{ selectedProduct: product }}&#13;
    key={product.id}&#13;
&gt;&#13;
  &lt;ProductItem product={product} /&gt;&#13;
&lt;/Link&gt;&#13;
</code></pre>
<p class="translated">在<code>&lt;Link&gt;</code>标签中，我们这次传入了两个道具:</p>
<ul>
<li class="translated">一个<code>to</code>属性，指定重定向到哪个路由。对于<code>to</code>属性，我们传入的是产品的ID，而不是路线的<code>:id</code>部分，这确保用户链接到一个带有产品自定义视图的特定产品页面。</li>
<li class="translated">一个<code>state</code>属性，它允许将信息传递给在<code>Link</code>组件重定向到的路径中呈现的组件。对于<code>state</code>属性，我们传入产品信息，该信息可以通过<code>selectedProduct</code>属性访问。</li>
</ul>
<h3 class="translated"><a id="spruce-up-your-product-details-page" class="anchor" href="#spruce-up-your-product-details-page" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>美化您的产品详情页面</h3>
<p class="translated">现在用户可以从主页访问<code>ProductIndividual</code>组件了，我们可以将它更新为从添加在<code>ProductsList</code>中的<code>Link</code>组件传递给它的表面信息。</p>
<p class="translated">在<code>client/src/components/ProductIndividual.js</code>中，添加以下导入:</p>
<pre><code class="language-jsx">import { useLocation } from "react-router-dom";&#13;
</code></pre>
<p class="translated">上面的语句从<code>react-router-dom</code>库中导入了一个<code>[useLocation</code>钩子】(https://react router . com/en/main/hooks/use-location)。<code>useLocation</code>允许你访问一个<code>location</code>对象，该对象详细描述了关于你当前所在的URL的信息，以及传入到那里的信息。该信息包括从<code>ProductsList</code>传入的<code>state</code>属性。<code>state</code>包含一个<code>selectedProduct</code>属性，其中包含从Commerce.js中检索到的所有产品信息。</p>
<p class="translated">让我们从使用<code>useLocation</code>挂钩开始！在<code>ProductIndividual.js</code>中<code>ProductIndividual()</code>的函数体顶部，添加以下几行代码:</p>
<pre><code class="language-jsx">const location = useLocation();&#13;
const selectedProduct = location.state?.selectedProduct;&#13;
</code></pre>
<p class="translated">上面的代码会通过<code>useLocation</code>钩子抓取<code>location</code>对象。然后，使用该对象，将所选产品的信息从该对象填充到<code>selectedProduct</code>中。</p>
<p class="translated">我们现在可以使用来自<code>location</code>对象的<code>selectedProduct</code>来显示与产品相关的一组特定信息(因为我们的目标是一个非常简单的产品详细信息页面，所以我们将只显示一个图像、一个名称和一个格式化的价格)。更新<code>ProductIndividual</code>组件中的<code>return()</code>,如下所示:</p>
<pre><code class="language-jsx">&lt;&gt;&#13;
  &lt;div className="item__container"&gt;&#13;
    &lt;img&#13;
      className="item__image"&#13;
      src={selectedProduct.image?.url}&#13;
      alt={selectedProduct.name}&#13;
    /&gt;&#13;
    &lt;div className="item__info"&gt;&#13;
      &lt;h3 className="item__name"&gt;{selectedProduct.name.toUpperCase()}&lt;/h3&gt;&#13;
      &lt;div className="item__details"&gt;&#13;
        &lt;p className="item__price"&gt;&#13;
          {selectedProduct.price.formatted_with_symbol}&#13;
        &lt;/p&gt;&#13;
      &lt;/div&gt;&#13;
    &lt;/div&gt;&#13;
  &lt;/div&gt;&#13;
&lt;/&gt;&#13;
</code></pre>
<p class="translated">最后，为了更新<code>ProductIndividual</code>组件新添加信息的样式并使其看起来更漂亮，将<code>ProductIndividual.css</code> 文件中的<a href="https://github.com/hello-ashleyintech/algolia-commercejs-recommendations-app/blob/master/client/src/components/ProductIndividual.css"> CSS添加到项目的<code>ProductIndividual.css</code>文件中。</a></p>
<p class="translated"><em>此时，您的应用程序现在应该能够:</em></p>
<ul>
<li class="translated">主页中的Surface单个产品详细信息页面</li>
<li class="translated">允许用户使用导航栏中的商店徽标从产品详细信息页面导航回主页</li>
</ul>
<p class="translated"><img loading="lazy" class="alignnone size-full wp-image-18190" src="../Images/fbd493d7fe2dfa36a0f5fa78a042609a.png" alt="" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2023/02/algolia-recommend-product-detail-demo.gif"/></p>
<h2 class="translated"><a id="add-in-event-tracking" class="anchor" href="#add-in-event-tracking" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>添加事件跟踪</h2>
<p class="translated">好消息—现在，用户可以在您的应用中访问单个产品的详细信息页面！🎉添加了这个功能后，我们可以开始跟踪用户交互，看看有什么趋势。对于我们的应用程序，我们将考虑一个“趋势项”,即用户持续交互的项。</p>
<p class="translated">由于我们的应用程序除了点击产品之外不包含任何交互，所以每当有人点击商品并导航到商品的详细页面时，我们都会记录一个到Algolia的转换事件。通常，如果我们的应用程序有更多的特性，我们可能会使用“添加到购物车”按钮交互作为转换事件。你可以在这里了解更多关于事件和向Algolia <a href="https://www.algolia.com/doc/guides/sending-events/getting-started/">发送事件的信息。</a></p>
<h3 class="translated"><a id="set-up-instantsearch" class="anchor" href="#set-up-instantsearch" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>设置即时搜索</h3>
<p class="translated">我们需要安装来自Algolia的三个包，以帮助我们实现基于用户点击记录转换事件的预期目标。这些包是<code>algoliasearch</code>、<code>react-instantsearch-dom</code>和<code>search-insights</code>。</p>
<p class="translated">您可以使用以下命令将它们一次性安装到项目的<code>client</code>目录中:</p>
<pre><code class="language-bash">npm i algoliasearch react-instantsearch-dom search-insights&#13;
</code></pre>
<p class="translated">为了跟踪用户交互，我们需要设置<a href="https://www.algolia.com/doc/guides/building-search-ui/what-is-instantsearch/js/"> InstantSearch </a>，这是一个开源UI库，支持各种搜索功能，包括将Algolia跟踪组件嵌入其实现中的能力。</p>
<p class="translated">首先将以下导入语句添加到<code>client/src/App.js</code>:</p>
<pre><code class="language-jsx">import aa from 'search-insights';&#13;
import algoliasearch from 'algoliasearch';&#13;
import { InstantSearch, Configure } from 'react-instantsearch-dom';&#13;
</code></pre>
<p class="translated">接下来，在<code>App()</code>函数声明的顶部添加以下内容:</p>
<pre><code class="language-jsx">const searchClient = algoliasearch(&#13;
  process.env.REACT_APP_ALGOLIA_APP_ID,&#13;
  process.env.REACT_APP_ALGOLIA_API_KEY&#13;
);&#13;
&#13;
aa('init', {&#13;
  appId: process.env.REACT_APP_ALGOLIA_APP_ID,&#13;
  apiKey: process.env.REACT_APP_ALGOLIA_API_KEY&#13;
});&#13;
</code></pre>
<p class="translated">上面通过Algolia Search初始化了一个搜索客户端，我们可以将它传递给Algolia的<code>InstantSearch</code>组件以及一个search insights实例，帮助记录用户交互。</p>
<p class="translated">接下来，我们将把每条路线的组件包装在一个<code>InstantSearch</code>组件中，并添加一个<code>Configure</code>组件，该组件专门支持在<code>InstantSearch</code>实例中跟踪点击。在您的<code>App.js</code>的<code>return()</code>语句中，用以下代码替换<code>&lt;Routes&gt;</code>标记中的代码:</p>
<pre><code class="language-jsx">&lt;Route&#13;
  exact&#13;
  path="/"&#13;
  element={&#13;
    &lt;InstantSearch searchClient={searchClient} indexName="products"&gt;&#13;
      &lt;Configure clickAnalytics /&gt;&#13;
      &lt;ProductsList products={products} /&gt;&#13;
      &lt;Bot /&gt;&#13;
    &lt;/InstantSearch&gt;&#13;
  }&#13;
/&gt;&#13;
&lt;Route&#13;
  exact&#13;
  path="/products/:id"&#13;
  element={&#13;
    &lt;InstantSearch searchClient={searchClient} indexName="products"&gt;&#13;
      &lt;Configure clickAnalytics /&gt;&#13;
      &lt;ProductIndividual /&gt;&#13;
      &lt;Bot /&gt;&#13;
    &lt;/InstantSearch&gt;&#13;
  }&#13;
/&gt;&#13;
</code></pre>
<p class="translated">每条路线的组件都用一个<code>InstantSearch</code>包装器包装，该包装器接收从<code>algoliasearch</code>初始化的<code>searchClient</code>。此外，它接受一个与您的产品同步到的Algolia索引相对应的<code>indexName</code>——在本例中，它是<code>products</code>。</p>
<h3 class="translated"><a id="add-an-event-to-log-insights" class="anchor" href="#add-an-event-to-log-insights" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>添加事件到日志洞察</h3>
<p class="translated">现在一切都已配置完毕，我们可以开始在主页上跟踪产品的转换事件了。更新<code>client/src/components/ProductsList.js</code>文件中的代码，如下所示:</p>
<pre><code class="language-jsx">import React from "react";&#13;
import { Link } from "react-router-dom";&#13;
import PropTypes from "prop-types";&#13;
import ProductItem from "./ProductItem";&#13;
import "./ProductsList.css";&#13;
import aa from "search-insights";&#13;
import { connectHitInsights } from "react-instantsearch-dom";&#13;
&#13;
function Product({ products }) {&#13;
  return (&#13;
    &lt;div className="products" id="products"&gt;&#13;
      {products.map((product) =&gt; (&#13;
        &lt;Link&#13;
          to={`/products/${product.id}`}&#13;
          state={{ selectedProduct: product }}&#13;
          key={product.id}&#13;
          onClick={() =&gt; {&#13;
            aa("convertedObjectIDs", {&#13;
              userToken: "user-1",&#13;
              index: "products",&#13;
              eventName: "Product conversion",&#13;
              objectIDs: [product.id],&#13;
            });&#13;
          }}&#13;
        &gt;&#13;
          &lt;ProductItem product={product} /&gt;&#13;
        &lt;/Link&gt;&#13;
      ))}&#13;
    &lt;/div&gt;&#13;
  );&#13;
}&#13;
&#13;
Product.propTypes = {&#13;
  products: PropTypes.array,&#13;
};&#13;
&#13;
const ProductsList = connectHitInsights(aa)(Product);&#13;
export default ProductsList;&#13;
</code></pre>
<p class="translated">我们在这里做了一些更新:</p>
<ul>
<li class="translated"><code>aa</code>和<code>connectHitInsights</code>作为进口增加。</li>
<li>The component’s functional declaration, <code>ProductsList()</code>, has been renamed to <code>Product()</code> — this is so we can connect the component’s declaration to Algolia’s Insights API later on in the file using the <code>connectHitInsights()</code> function, which will then be stored and exported as the <code>ProductsList</code> component. This is accomplished in the following line of code at the end of the file:
<pre><code class="language-jsx">const ProductsList = connectHitInsights(aa)(Product);&#13;
</code></pre>
<p class="translated">由于这一变化，当拉动<code>Product()</code>组件初始化下面的<code>propTypes</code>时，<code>ProductsList</code>也被换成了<code>Product</code>。</p></li>
<li class="translated"><code>Link</code>组件添加了一个<code>onClick()</code>监听器。因为我们将用户点击产品视为转换，所以每当用户点击产品时，<code>onClick()</code>监听器将使用<code>search-insights</code>库中的<code>aa</code>来记录一个<code>[convertedObjectIDs</code>事件(https://www . algolia . com/doc/API-reference/API-methods/converted-object-ids/)。<code>aa</code>事件记录还需要一些其他参数:<ul>
<li class="translated">一个<code>userToken</code>，我们硬编码为<code>user-1</code>。这是一个唯一的用户ID——如果您为您的应用程序使用单独的用户帐户，您将检索当前用户的ID并在此处填充它。</li>
<li class="translated">一个<code>index</code>，这是我们的产品所对应的Algolia指数，在这种情况下，它是<code>products</code>。</li>
<li class="translated">这可以是你想要的任何东西。</li>
<li class="translated"><code>objectIDs</code> —这是一系列与此事件相关的产品。因为我们的应用程序为每一次产品点击记录一个事件，所以我们总是只传入一个产品ID。</li>
</ul>
</li>
</ul>
<h3 class="translated"><a id="confirm-events-are-being-sent-to-algolia" class="anchor" href="#confirm-events-are-being-sent-to-algolia" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>确认事件正在被发送到阿哥利亚</h3>
<p class="translated">至此，向Algolia发送转换事件的所有设置都已添加完毕。但是…这些事件在哪里结束？我们怎么知道所有的重担是否值得？</p>
<p class="translated">答案很简单——你可以进入Algolia仪表盘的<a href="https://www.algolia.com/events/studio">事件</a>部分！本节由两部分组成:</p>
<ul>
<li class="translated"><a href="https://www.algolia.com/events/studio">事件中心</a>，将显示过去7天发送到Algolia的所有事件的仪表板:<img loading="lazy" class="alignnone size-full wp-image-18188" src="../Images/32a120a7971999e531cdf66b0c954d05.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.16.53_PM.png 2948w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.16.53_PM-320x147.png 320w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.16.53_PM-720x331.png 720w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.16.53_PM-768x353.png 768w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.16.53_PM-1536x705.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.16.53_PM-2048x941.png 2048w" sizes="(max-width: 2948px) 100vw, 2948px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.16.53_PM.png"/></li>
<li class="translated"><a href="https://www.algolia.com/events/debugger">事件调试器</a>，它显示了事件进来时的详细的、逐个事件的分解:<img loading="lazy" class="alignnone size-full wp-image-18187" src="../Images/5bf29f5213962e9db0c417fdb7fd8378.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.17.15_PM.png 2936w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.17.15_PM-320x139.png 320w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.17.15_PM-720x312.png 720w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.17.15_PM-768x333.png 768w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.17.15_PM-1536x665.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.17.15_PM-2048x887.png 2048w" sizes="(max-width: 2936px) 100vw, 2936px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.17.15_PM.png"/></li>
</ul>
<p class="translated">当您看到您的活动出现在Algolia界面上并带有<code>200</code>状态代码时，您就知道这些活动已成功发送。要了解更多关于调试和验证事件的信息，你可以访问<a href="https://www.algolia.com/doc/guides/sending-events/validating/">这篇文章</a>。</p>
<h2 class="translated"><a id="the-final-frontier-surface-trending-product-recommendations" class="anchor" href="#the-final-frontier-surface-trending-product-recommendations" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>最终前沿:表面趋势产品推荐</h2>
<p class="translated">此时，您成功地将应用用户的转化事件发送到了Algolia。现在你有了所有这些漂亮的数据，你该怎么处理呢？</p>
<p class="translated">介绍<a href="https://www.algolia.com/doc/guides/algolia-recommend/overview/"> Algolia推荐</a> —一个易于使用的Algolia功能，它获取事件数据，训练机器学习模型识别数据中的期望模式，然后将信息显示在您的网站上！</p>
<p class="translated">虽然这听起来可能很复杂，但Algolia让它变得非常简单——你需要做的只是收集事件并提交表单，然后他们会做剩下的事情。但是，要确保为您想要使用的推荐模型收集正确类型的事件。您可以在此查看各型号<a href="https://www.algolia.com/doc/guides/algolia-recommend/overview/#events-requirements-for-the-models">的要求。</a></p>
<h3 class="translated"><a id="generate-a-recommend-model" class="anchor" href="#generate-a-recommend-model" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>生成推荐模型</h3>
<p class="translated">对于这个特定的教程，我们将为“趋势推荐”生成一个推荐模型，这需要在3天的时间内对一个特定的索引进行至少500次转换事件。要获得您需要的数据，您可以暂时在这里暂停，让您的应用程序有机地生成这些事件，或者我们可以走捷径，生成一个事件数据的CSV<a href="https://www.algolia.com/doc/guides/algolia-recommend/how-to/csv-upload/?utm_medium=page_link&amp;utm_source=dashboard">。为了测试本教程，我们创建了一个假的CSV，它包含名为<code>userToken</code>、<code>timestamp</code>、<code>objectID</code>、<code>eventType</code>和<code>eventName</code>的列。然后，我们为3个不同的日子生成3个不同的时间戳，用这些时间戳填充<code>timestamps</code>列，并为我们的索引中的产品随机添加<code>objectID</code>。</a></p>
<p class="translated">一旦你有了你的数据，在你的仪表板上进入<a href="https://www.algolia.com/recommend/models">推荐模型</a>页面，选择“趋势推荐”选项。对于数据源，请选择您用来存储电子商务商店商品的索引。</p>
<p class="translated">第二步，添加您的数据。如果您在3天内手动生成了500个转换事件，则可以跳过这一步，除非除了您选择作为数据源的事件之外，还有任何事件记录到其他索引中。如果您已经创建了包含所有活动数据的CSV，您将在此步骤中使用“上传CSV”按钮上传它。</p>
<p class="translated">接下来，确保选择了“趋势项目”选项。然后，您可以单击“开始训练”按钮。您推荐的模型将开始训练，根据您拥有的数据，训练可能需要几分钟到几个小时。当您在模型页面上看到类似以下内容时，您就知道您的模型已经完成了训练:</p>
<p class="translated"><img loading="lazy" class="alignnone size-full wp-image-18186" src="../Images/645c4272d3b2a74d014cf22a941c77e5.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.40.10_PM.png 2972w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.40.10_PM-320x136.png 320w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.40.10_PM-720x307.png 720w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.40.10_PM-768x327.png 768w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.40.10_PM-1536x654.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.40.10_PM-2048x872.png 2048w" sizes="(max-width: 2972px) 100vw, 2972px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-08_at_4.40.10_PM.png"/></p>
<p class="translated">如果您遇到任何问题或模型失败，您可能需要检查您的数据和模型所需的数据标准，以确保一切按预期运行。一旦您做出了任何需要的更改，您总是可以提交带有新数据的模型来重新训练它。你可以点击查看完整的Algolia推荐设置指南<a href="https://www.algolia.com/doc/guides/algolia-recommend/how-to/set-up/">。</a></p>
<h3 class="translated"><a id="surface-trending-items-on-your-app" class="anchor" href="#surface-trending-items-on-your-app" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>app上的表面趋势项目</h3>
<p class="translated">一旦你的模型被训练好，你就可以把这些生成的建议放到你的应用中。Algolia通过两个库使这个过程变得简单明了:<code>@algolia/recommend-react</code>和<code>@algolia/recommend</code>。将它们都安装到您项目的<code>client</code>目录中:</p>
<pre><code class="language-bash">npm i @algolia/recommend-react @algolia/recommend&#13;
</code></pre>
<p class="translated">为了提供建议，我们将创建一个新的组件，它将从我们的趋势项目模型中提取数据，然后在UI中呈现出来。</p>
<p class="translated">在<code>client/src/components</code>中，创建一个名为<code>RecommendationCard.js</code>的文件。这将是一个<code>RecommendationCard</code>组件，一个类似于<code>ProductIndividual</code>组件的简单组件，它将把关于产品的数据作为道具，并在其上显示特定信息:</p>
<pre><code class="language-jsx">// client/src/component/RecommendationCard.js&#13;
import React from "react";&#13;
import PropTypes from "prop-types";&#13;
&#13;
function RecommendationCard({ product }) {&#13;
  return (&#13;
    &lt;&gt;&#13;
      &lt;div className="rec__card"&gt;&#13;
        &lt;img&#13;
          className="rec__image"&#13;
          src={product.image?.url}&#13;
          alt={product.name}&#13;
        /&gt;&#13;
        &lt;div className="rec__info"&gt;&#13;
          &lt;h4 className="rec__name"&gt;{product.name.toUpperCase()}&lt;/h4&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
    &lt;/&gt;&#13;
  );&#13;
}&#13;
&#13;
RecommendationCard.propTypes = {&#13;
  product: PropTypes.object,&#13;
};&#13;
&#13;
export default RecommendationCard;&#13;
</code></pre>
<p class="translated">添加完<code>RecommendationCard</code>后，在<code>client/src/components</code>中创建一个<code>Recommendations.js</code>文件，这是一个通用<code>Recommendations</code>组件，包含从Algolia发送的每个趋势项的<code>RecommendationCard</code>:</p>
<pre><code class="language-jsx">// client/src/component/Recommendations.js&#13;
import React from "react";&#13;
import { Link } from "react-router-dom";&#13;
import { useTrendingItems } from "@algolia/recommend-react";&#13;
import recommend from "@algolia/recommend";&#13;
import aa from "search-insights";&#13;
import RecommendationCard from "./RecommendationCard";&#13;
import "./Recommendations.css";&#13;
&#13;
function Recommendations() {&#13;
  const recommendClient = recommend(&#13;
    process.env.REACT_APP_ALGOLIA_APP_ID,&#13;
    process.env.REACT_APP_ALGOLIA_API_KEY&#13;
  );&#13;
  const indexName = "products";&#13;
&#13;
  const { recommendations } = useTrendingItems({&#13;
    recommendClient,&#13;
    indexName,&#13;
  });&#13;
&#13;
  return (&#13;
    &lt;div className="trending__container"&gt;&#13;
      &lt;h2&gt;TRENDING ITEMS&lt;/h2&gt;&#13;
      &lt;div className="trending__grid"&gt;&#13;
        {recommendations.map((product) =&gt; (&#13;
          &lt;Link&#13;
            to={`/products/${product.id}`}&#13;
            state={{ selectedProduct: product }}&#13;
            key={product.id}&#13;
            onClick={() =&gt; {&#13;
              aa("convertedObjectIDs", {&#13;
                userToken: "user-1",&#13;
                index: "products",&#13;
                eventName: "Product conversion",&#13;
                objectIDs: [product.id],&#13;
              });&#13;
            }}&#13;
          &gt;&#13;
            &lt;RecommendationCard product={product} /&gt;&#13;
          &lt;/Link&gt;&#13;
        ))}&#13;
      &lt;/div&gt;&#13;
    &lt;/div&gt;&#13;
  );&#13;
}&#13;
&#13;
export default Recommendations;&#13;
</code></pre>
<p class="translated">该组件使用Algolia的<code>useTrendingItems</code>钩子来查询我们生成的趋势项目模型的结果。<code>useTrendingItems</code>需要传入一个<code>recommendClient</code>,它是使用<code>@algolia/recommend</code>库的<code>recommend</code>函数初始化的。</p>
<p class="translated">与<code>ProductsList</code>类似，该组件随后遍历Algolia返回的建议数组，并呈现一个<code>RecommendationCard</code>，呈现每个产品的数据。<code>RecommendationCard</code>封装在一个<code>Link</code>组件中，该组件将用户路由到所选推荐的产品页面，并通过一个<code>onClick()</code>监听器记录一个转换事件。</p>
<p class="translated">当您准备好在您的产品详情页面上展示您的建议时，请进入<code>client/src/components/ProductIndividual.js</code>并导入您的<code>Recommendations</code>组件:</p>
<pre><code class="language-jsx">import Recommendations from "./Recommendations";&#13;
</code></pre>
<p class="translated">然后，将组件添加到组件的<code>return()</code>中的<code>&lt;/&gt;</code>结束标记之前:</p>
<pre><code class="language-jsx">&lt;Recommendations /&gt;&#13;
</code></pre>
<p class="translated">此时，<code>Recommendations</code>组件应该出现在您的产品详细信息页面上，但是它看起来可能有点滑稽。如果你想为这个组件添加一些简单的样式，使它看起来像下面的页面，在<code>client/src/components</code>目录中创建<code>Recommendations</code>和<code>RecommendationCard</code> CSS文件。从那里，您可以将我们的<code>[Recommendations</code> CSS文件】(https://github . com/hello-Ashley intech/algolia-commerce js-recommendations-app/blob/master/client/src/components/recommendationcard . CSS)和<code>[RecommendationCard</code> CSS文件】(https://github . com/hello-Ashley intech/algolia-commerce js-recommendations-app/blob/master/client/src/components/recommendation card . CSS)的内容复制到您的本地组件。</p>
<p class="translated"><img loading="lazy" class="alignnone size-full wp-image-18185" src="../Images/6beed669046da4b9420996ae77074365.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-09_at_6.16.17_PM.png 3544w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-09_at_6.16.17_PM-320x173.png 320w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-09_at_6.16.17_PM-720x390.png 720w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-09_at_6.16.17_PM-768x416.png 768w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-09_at_6.16.17_PM-1536x831.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-09_at_6.16.17_PM-2048x1108.png 2048w" sizes="(max-width: 3544px) 100vw, 3544px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2023/02/Screen_Shot_2023-01-09_at_6.16.17_PM.png"/></p>
<h1 class="translated"><a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>结论</h1>
<p class="translated">恭喜你！🥳:你已经创建了一个漂亮的电子商务应用程序，允许你根据真实的用户趋势来展示流行产品！你可以在这里查看整个项目的GitHub库<a href="https://github.com/hello-ashleyintech/algolia-commercejs-recommendations-app"/>。通常，这种类型的功能需要几天的编码和相当多的机器学习知识。然而，有了Algolia的魔力，你节省了自己的时间<em>和</em>许多受挫的谷歌搜索从零开始训练机器学习模型。✨</p>
<p class="translated">正如您在本教程中了解到的，<a href="https://www.algolia.com/doc/guides/algolia-recommend/overview/"> Algolia推荐</a>是一个强大的工具，可以帮助客户获得更有帮助、更个性化的电子商务体验。如果您有兴趣进一步扩展我们今天构建的应用程序，请随意查看其他类型的模型及其所需的数据类型<a href="https://www.algolia.com/doc/guides/algolia-recommend/overview/#events-requirements-for-the-models">此处</a>并探索如何使用Algolia为您的客户添加更多个性化体验。此外，请继续关注即将推出的另一个教程，学习如何为您的电子商务应用程序实现个性化搜索结果！🎉</p>
</div></div>    
</body>
</html>