<html>
<head>
<title>Master the Rebase (and the Other Way Around) | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Rebase(反之亦然)</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/master-git-rebase/#0001-01-01">https://www.algolia.com/blog/engineering/master-git-rebase/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="translated">git‘rebase’是您可能听说过的替代‘merge’的命令之一。事实上，不止如此——“rebase”是一套完全不同的工具，与“merge”所实现的目标相互交叉。迷茫？放心吧！这篇博文是关于“rebase”的不同用法。首先，作为一种在两个分支之间整合和交换你的工作的方式(就像“合并”一样)，也作为一种历史重写工具。</p>
<h2 class="translated"><a id="from-merge-to-rebase" class="anchor" href="#from-merge-to-rebase" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>从合并到变基</h2>
<p class="translated">合并分支是集成两个Git分支之间变更的最常见方式。GitHub或Gitlab等服务常见的Git工作流程如下:</p>
<ul>
<li class="translated">从基础分支(如“主”或“开发”)创建名为“我的新功能”的新“功能”分支</li>
<li class="translated">做一些工作，并将更改提交到特征分支</li>
<li class="translated">将功能分支推送到集中共享回购</li>
<li class="translated">为“我的新功能”打开新的拉式请求</li>
<li class="translated">等待您的测试通过，并从您的同事那里收集反馈</li>
</ul>
<p class="translated">从那以后，一切都很好。您最终会得到一个漂亮、干净的分支，例如:</p>
<p class="translated"><a href="https://blog-api.algolia.com/wp-content/uploads/2017/12/image5.png"> <img loading="lazy" src="../Images/830a7b885ce0777855c3e20fe874c5dd.png" alt="Nice clean Git branch " data-original-src="https://blog-api.algolia.com/wp-content/uploads/2017/12/image5.png"/> </a></p>
<p class="translated">然而，在一个不完美的世界里，接下来可能会发生什么:</p>
<ul>
<li class="translated">代码审查人员在您的第一次提交中发现了一些错误和打字错误，您的测试没有通过</li>
<li class="translated">您进行一些更改，并在本地提交修复</li>
<li class="translated">您将更新后的特性分支推送到集中共享的repo(以下模式中的C6和C7)</li>
<li class="translated">同时，其他提交被合并到基础分支(C8和C9)</li>
<li class="translated">您的拉请求最终被接受，并被合并到基础分支(C10)中</li>
</ul>
<p class="translated">从那以后，你的历史变得有点复杂:</p>
<p class="translated"><a href="https://blog-api.algolia.com/wp-content/uploads/2017/12/image3.png"> <img loading="lazy" src="../Images/f457d7fa600c59d6fad0502d5b6ebe29.png" alt="Git history becomes more complex" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2017/12/image3-720x158.png"/> </a></p>
<p class="translated">这个工作流程没什么问题；特别是，你不必担心你的同事在做什么，这样你就可以专注于自己的工作。由于Git将您的变更与来自基础分支的变更组合(或合并)的关键部分只发生一次，所以您只需要处理一次最终的冲突——在合并步骤。</p>
<p class="translated">然而，有几件事也有点不对劲。首先，如果您在您的分支上工作的时间足够长，您可能会在几天或几周内与基础分支失去同步。这可能不是一个问题，但有时你真的会感激包括你的团队合并的那个特定的修正，或者摆脱那个每次编译都使你变慢的巨大的依赖。其次，一旦您的所有同事都将自己的分支机构合并到基础分支机构，历史记录可能会变得过于复杂而难以理解。最后——这个可能更主观一些——您可能在分支的提交之间保留了一个逻辑分解。拥有一个包含对所有文件的所有更改的合并提交可能不是您最终想要公开的。</p>
<p class="translated">让我们来看看重定基准如何帮助您解决所有这些问题。</p>
<h2 class="translated"><a id="rebasing-on-the-base-branch" class="anchor" href="#rebasing-on-the-base-branch" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>在基础分支上重设基础</h2>
<p class="translated">2016年9月，GitHub推出了<a href="https://github.com/blog/2243-rebase-and-merge-pull-requests" target="_blank" rel="noopener noreferrer">合并拉取请求的新方式</a>:“Rebase and merge”按钮。其他库管理器(如GitLab)也可以使用它，它是“rebase前门”。它允许您在您的基本分支之上执行您的拉请求提交的单个rebase操作，然后执行合并。观察这两个操作是按顺序执行的，并且重定基础不是合并的替代，这一点非常重要。因此，rebase不用于替换合并，但是它完成了合并。</p>
<p class="translated">考虑前面的例子。在最终合并之前，我们处于这种情况:</p>
<p class="translated"><a href="https://blog-api.algolia.com/wp-content/uploads/2017/12/image2.png"> <img loading="lazy" src="../Images/88fc1d544b540a7ea6a6d9d08361130a.png" alt="situation before the final merge" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2017/12/image2-720x239.png"/> </a></p>
<p class="translated">通过执行以下命令，您可以模拟当您单击“Rebase and merge”(没有冲突时)时会发生什么:</p>

<p class="translated">这样做，你最终会得到一个“线性历史”:</p>
<p class="translated"><a href="https://blog-api.algolia.com/wp-content/uploads/2017/12/image4.png"> <img loading="lazy" src="../Images/1edaffb880ef15a79447cf722a575e98.png" alt="linear Git history" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2017/12/image4-720x136.png"/> <br/> </a>如你所见，重置基础并不能替代合并步骤。如前所述，这两个操作不是在同一个分支上执行的:在特征分支上使用“rebase ”,而在基本分支上执行“merge”。目前，这个操作只是阻止了一个包含所有变更的合并提交，它仍然是一个发生在您的贡献的最后一步的操作(例如，当您想要共享您的工作时)。</p>
<p class="translated">到目前为止，我们只与“大师”作为我们的基本分支进行互动。为了与基础分支的变更保持同步，只需要用最新的基础分支执行rebase步骤。你等待的时间越长，你就越不同步。</p>
<p class="translated">您的基本分支的最新版本隐藏在显眼的地方。它是基本分支的只读版本，以您所连接的远程的名称为前缀，或者更简单地说:它是来自您的远程实例(如GitHub或GitLab)的分支的只读副本。首次克隆存储库时，默认前缀是“origin”。更具体地说，您的“主”分支是master的本地版本，而“origin/master”是该分支的远程版本，是您上次执行“git fetch”操作时在您的计算机上复制的。</p>
<p class="translated">我们已经浏览了很多理论材料，但结果是，最终结果相对简单明了；以下是如何同步遥控器上发生的变化:</p>

<p class="translated">第一步是从“主文件”的远程副本中检索最新的更改到您的本地“源/主文件”分支中。第二个检查您的特征分支。最后一个执行“rebase ”,这样您所有的提交现在都被添加到与您自己的工作并行发生的最新变更之上。通过在我们的第一个示例中应用这些命令，将会发生以下情况:</p>
<p class="translated"><a href="https://blog-api.algolia.com/wp-content/uploads/2017/12/image1.png"> <img loading="lazy" src="../Images/e62fd4a503ac7fddf89fdf902db7bff7.png" alt="the feature branch now includes all the latest changes" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2017/12/image1.png"/> </a>如你所见，特性分支现在包含了所有最新的变更，所以你可以和你团队的其他成员同步工作。通过使用上面的工作流，您将能够更早地逐步处理潜在的冲突，而不是在最后一刻(当您想要在基本分支内合并您的工作时)。人们经常忽略“Rebase and merge”按钮，因为他们预计在过程的最后一步会有太多的冲突(所以他们更喜欢执行常规的合并提交)。最终，它需要一点积极的努力来与最新的变化保持同步。</p>
<h2 class="translated"><a id="rebasing-your-own-work" class="anchor" href="#rebasing-your-own-work" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>调整自己的工作</h2>
<p class="translated">到目前为止，我们只使用“rebase”将提交从一个分支应用到另一个分支。这几乎是“rebase”的基本用例:只有默认选项、动作和结果。此外，我们只是使用“rebase”将不同分支的变更整合到我们自己的分支中。但是——它也可以用来直接从您自己的分支添加/更改/删除您的提交！您重定基础的“基础”实际上可以是任何提交——甚至是直接祖先。</p>
<p class="translated">事实上，如果你想看看在我们做的rebase期间发生了什么，你可以使用rebase的“交互模式”,添加`-i '或`–interactive '参数。通过这样做，Git将打开您选择的编辑器(在您的“editor”环境变量中定义的编辑器),并列出将受rebase操作影响的所有提交，以及应该对每一个提交做什么。这就是“重定基数”的真正力量所在。</p>
<p class="translated">从您的编辑器中，Git允许您重新排序、重命名或删除提交，但是您也可以将单个提交拆分成多个提交，将两个或多个提交合并在一起，或者同时更改它们的提交消息！几乎所有你想对你的历史做的事情都可以通过“rebase”实现。令人惊叹的是，告诉Git做什么相对简单。每个提交都在自己的行上按顺序显示，以将要应用的命令为前缀。对提交进行重新排序就像对行进行重新排序一样简单，最近的提交在列表的底部。删除提交只是删除相应的行，或者指定' d '或' drop '命令作为前缀。你的信息中有一个打字错误？只需使用“r”或“reword”命令来保持提交，但更改相关的提交消息。</p>
<p class="translated">总而言之，“rebase”只是一个Git命令，它可以让您:</p>
<ul>
<li class="translated">选择一个或多个连续提交</li>
<li class="translated">基于您的存储库的任何提交</li>
<li class="translated">将更改应用到此提交序列，因为它们被添加到新的基本提交之上</li>
</ul>
<p class="translated">为了更好地说明这一点，考虑以下一系列提交:</p>

<p class="translated">正如您在这里看到的，我们有第一个“根提交”，这将作为我们的基本提交，随后是4个提交，将总共5个文件添加到存储库中。为了便于练习，假设这一系列提交是您的拉请求，您对它不满意，原因如下:</p>
<ul>
<li class="translated">第一个提交消息是错误的:它应该是“添加文件”，而不是“添加A”</li>
<li class="translated">文件B和C以错误的顺序添加</li>
<li class="translated">文件D应该与文件C同时添加，而不是与文件E一起添加</li>
<li class="translated">最后，文件E应该添加到它自己单独的提交中</li>
</ul>
<p class="translated">所有这些变化都可以用一个简单的重定基准来完成。最终的历史将如下所示:</p>

<p class="translated">请注意，除了我们的基本提交之外，所有提交散列都已更改。这是由于Git生成提交散列的方式，它不仅基于更改本身，还基于父提交散列和其他元数据。</p>
<p class="translated">无论如何，让我们重新开始！</p>
<p class="translated">让我们从一个‘git rebase-I HEAD ~ 4’开始。这告诉Git交互地重新设置HEAD中最后4次提交的基础。“head～4”指向“根提交”,这是我们将重新基于的提交。按ENTER键后，您选择的编辑器将打开(在Unix风格的系统上，默认为“vi”)。在这里，Git只是简单地问你想对你执行的提交做什么。</p>

<p class="translated">如前所述，每一行都代表一次提交，以将要应用的相应rebase命令为前缀。所有的注释行在重定基础时都会被忽略，这里是提醒你现在该做什么。在我们的例子中，我们将使用以下命令:</p>

<p class="translated">在这里，我们告诉Git在rebase期间为我们执行三项任务:</p>
<ul>
<li class="translated">在第一次提交时停止，让我们更改提交消息</li>
<li class="translated">对第二个和第三个提交进行重新排序，使它们具有正确的顺序</li>
<li class="translated">停在最后一个提交，让我们做一些手动修改</li>
</ul>
<p class="translated">保存文件并退出编辑器后，您将再次看到编辑器，第一条提交消息将出现在您面前。重置正在进行，系统会提示您更改第一个提交消息。我们把它从“添加一个”改成“添加一个文件”，然后保存并退出。</p>
<p class="translated">第二次和第三次提交的重新排序是由Git透明地完成的。这给我们留下了我们要求执行的最后一个修改。这里，我们在“添加D和E文件”提交后停止。因为我们想用C和D文件创建一个提交，并且只为E创建一个新的提交，所以我们需要执行以下步骤，就像我们在我们的分支顶部修改附加提交一样:</p>

<p class="translated">这些命令(除了最后一个)使“添加C文件”和“添加D和E文件”提交成为我们想要的“添加C和D文件”和“添加E文件”提交。不过，最后一个命令只是通知Git我们已经完成了“编辑”步骤。之后，Git会很高兴地告诉你rebase成功完成。太好了！</p>
<p class="translated">我们已经介绍了您可能想对提交历史做的几乎所有事情。还有一些命令可用，根据您的使用情况，它们可能会对您有更好的帮助。</p>
<h2 class="translated"><a id="handling-conflicts" class="anchor" href="#handling-conflicts" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>处理矛盾</h2>
<p class="translated">当谈到使用“重定基础”时，人们经常对如何解决冲突感到困惑，这种冲突可能发生在将一个分支重定基础到另一个分支之上时。由于多种原因，当Git出现冲突时，解决冲突实际上很方便。</p>
<p class="translated">首先，当冲突出现时，Git不会试图比你更聪明——它会停止当前的“rebase ”,并要求你解决冲突。冲突文件将被标记为“均已修改”，冲突部分将有一些标记来帮助您找到不同之处。当您完成修改后，您可以“git add”修改后的文件，并运行“git rebase–continue”让rebase继续运行。</p>
<p class="translated">第二，当你对正在进行的重定基数或重定基数出错没有信心时，有两种工具非常有效。考虑“git rebase–abort ”,它将历史倒回到当前Git rebase操作之前。</p>
<p class="translated">通过这些技术，使用“rebase”所做的更改可以撤消，因此出错的风险最小。</p>
<p class="translated">最后，你可能会发现自己在处理一个漫长而无聊的冲突，即使这样，同样的冲突也有可能在不同的时间再次发生。例如，不幸的是，当您在自己的分支上工作时，基础分支发生变化是很常见的。另一种情况是，您中止了一个重定基础，现在正试图重做该重定基础。为了避免再次解决相同的冲突，Git提供了一个默认禁用的解决方案。此功能名为“重复使用记录的分辨率”或“rerere ”,可通过“git config–global rerere . enabled true”启用。这样，Git将跟踪您执行的所有冲突解决方案。当完全相同的冲突再次发生时，您应该从Git输出中看到使用了记录的解决方案。</p>
<h2 class="translated"><a id="going-further" class="anchor" href="#going-further" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>更进一步</h2>
<p class="translated">我希望这篇文章能帮助你了解“rebase”命令的作用。当然，学习Git的最好方法是使用它，但是第二好的方法是阅读它。如果你想阅读更多，我强烈推荐<a href="https://git-scm.com/book/" target="_blank" rel="noopener noreferrer"> Pro Git </a>这本书——特别是关于<a href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing" target="_blank" rel="noopener noreferrer"> rebase </a>本身的部分。而且，因为偶尔我们都会陷入糟糕的境地，所以您可能应该看看<a href="https://git-scm.com/book/en/v2/Git-Internals-Maintenance-and-Data-Recovery" target="_blank" rel="noopener noreferrer">维护和数据恢复部分</a>中的数据恢复。如果你不喜欢阅读整个文档，也许你更喜欢这些<a href="https://github.com/k88hudson/git-flight-rules" target="_blank" rel="noopener noreferrer"> Git飞行规则</a>。</p>
<p class="translated">对这篇文章有更多的建议或反馈吗？我很想听听他们:<a href="https://twitter.com/aseure" target="_blank" rel="noopener noreferrer">@ a sure</a>。感谢您的阅读——祝您愉快！</p>
</div></div>    
</body>
</html>