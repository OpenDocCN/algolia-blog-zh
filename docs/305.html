<html>
<head>
<title>Creating an omnibar with Autocomplete - Algolia Blog | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个带有自动完成功能的omnibar</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/creating-an-omnibar-with-autocomplete/#0001-01-01">https://www.algolia.com/blog/engineering/creating-an-omnibar-with-autocomplete/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="translated">什么时候搜索栏不是搜索栏？当它是一个用Autocomplete构建的“omnibar”时！</p>
<p class="translated"><iframe src="https://www.youtube.com/embed/ghy7a78JGCQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen">视频</iframe></p>
<p class="translated">在《与杰森一起学习》的<a href="https://www.learnwithjason.dev/javascript-autocomplete">一集中</a>，<a href="https://twitter.com/frontstuff_io">莎拉·达扬</a>提到了使用自动完成来创造一种充满快捷方式和超级用户启示的体验的想法。</p>
<p class="translated">在本教程中，我们将通过设置<a href="https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/autocomplete-js/autocomplete/">自动完成</a>来触发与JavaScript的交互。具体来说，我们将构建一个omnibar来切换网站的明暗模式。omnibar是一个搜索字段，既有搜索功能，也有可以执行的操作。Chrome或Firefox的搜索和URL栏就是一个很好的例子。</p>
<p class="translated">在搜索栏中，用户可以输入<code>/</code>命令。这些命令将被绑定到特定的JavaScript方法来触发。我们还将使自动完成结果有状态。当应用程序处于灯光模式时，灯光模式选项将显示“已启用”标志。启用黑暗模式时，黑暗模式选项将显示标志。</p>
<p class="translated"><a href="https://codesandbox.io/s/autocomplete-actions-finished-eh7xw">自己试一试！</a></p>
<h2 class="translated"><a id="configuring-autocomplete-for-use-with-react" class="anchor" href="#configuring-autocomplete-for-use-with-react" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>配置与React一起使用的自动完成功能</h2>
<p class="translated">在其核心，自动完成是一个普通的JavaScript库。让我们通过将它作为React组件安装在任何基于React的框架或站点中来使它更具可重用性。</p>
<p class="translated">我们将从CodeSandbox的基本React沙箱开始。<a href="https://alg.li/omnibar-starter">分叉这个沙箱</a>以获得所有为我们安装的包的准确起点。</p>
<p class="translated">为了创建我们的组件，我们将从添加一个名为<code>Autocomplete.js</code>的新文件开始。这个文件将包含自动完成库的所有初始化代码，并导出组件以供我们的应用程序使用。</p>
<p class="translated">在新文件的顶部，从React、React-dom和Autocomplete库中导入必要的元素。</p>
<pre class="lang:javascript decode:true ">import React, { createElement, Fragment, useEffect, useRef } from "react";  &#13;
import { render } from "react-dom";  &#13;
import { autocomplete } from "@algolia/autocomplete-js";</pre>
<p class="translated">一旦导入，我们需要导出一个新的功能性React组件。我们将从创建新的挂载组件的基本样板文件开始。</p>
<pre class="lang:javascript decode:true ">export function Autocomplete(props) {  &#13;
  const containerRef = useRef(null);  &#13;
&#13;
  useEffect(() =&gt; {  &#13;
    if (!containerRef.current) {  &#13;
      return undefined;  &#13;
    }&#13;
&#13;
    // Space to initialize autocomplete on the newly created container&#13;
&#13;
    // Destroy the search instance in cleanup  &#13;
    return () =&gt; {  &#13;
      search.destroy();  &#13;
    };  &#13;
&#13;
  }, [props]);&#13;
&#13;
  return /&lt;div ref={containerRef} //&gt;;  &#13;
}</pre>
<p class="translated">这段代码将负责组件在安装和卸载时的基本初始化和分解。</p>
<p class="translated">在函数内部，是时候初始化Autocomplete实例了。</p>
<pre class="lang:javascript decode:true ">// Creates an Autcomplete component from the JS library&#13;
// https://www.algolia.com/doc/ui-libraries/autocomplete/guides/using-react/&#13;
export function Autocomplete(props) {&#13;
  const containerRef = useRef(null);&#13;
&#13;
  useEffect(() =&gt; {&#13;
    if (!containerRef.current) {&#13;
      return undefined;&#13;
    }&#13;
&#13;
    // Initialize autocomplete on the newly created container&#13;
    const search = autocomplete({&#13;
      container: containerRef.current,&#13;
      renderer: { createElement, Fragment },&#13;
      // Autocomplete render()&#13;
      // https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/autocomplete-js/autocomplete/#param-render&#13;
      render({ children }, root) {&#13;
        // react-dom render&#13;
        // https://reactjs.org/docs/react-dom.html#render&#13;
        render(children, root);&#13;
      },&#13;
      ...props&#13;
    });&#13;
&#13;
    // Destroy the search instance in cleanup&#13;
    return () =&gt; {&#13;
      search.destroy();&#13;
    };&#13;
  }, [props]);&#13;
&#13;
  return &lt;div ref={containerRef} /&gt;;&#13;
}</pre>
<p class="translated"><code>autocomplete</code>方法接受一个选项对象。我们将<code>container</code>属性设置为该函数创建的元素。通过指定<code>renderer</code>函数，我们可以使用React的<code>createElement</code>方法和<code>Fragment</code>组件。</p>
<p class="translated">然后，我们需要为Autocomplete提供一个<code>render</code>函数。该函数将接受一个要呈现的组件对象(<code>children</code>)，以及附加到实例的元素(<code>root</code>)。</p>
<p class="translated">然后，我们可以使用任何方法来呈现这些项目。在我们的例子中，我们将使用<code>react-dom</code>的<code>render()</code>方法，并向它传递那些相同的元素。最后，我们想通过<code>autocomplete</code>方法传递我们使用组件时添加到组件中的任何附加道具。这将允许即时定制。</p>
<h2 class="translated"><a id="using-the-autocomplete-component" class="anchor" href="#using-the-autocomplete-component" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#using-the-raw-ltautocomplete-gt-endraw-component" name="using-the-raw-ltautocomplete-gt-endraw-component"/>使用<code>&lt;Autocomplete /&gt;</code>组件</h2>
<p class="translated">转到<code>App.js</code>文件，我们可以导入我们的自动完成组件(以及一些默认样式)。</p>
<pre class="lang:javascript decode:true ">// Styles&#13;
import "./styles.css";  &#13;
import "@algolia/autocomplete-theme-classic";  &#13;
&#13;
// Import algolia and autocomplete needs&#13;
import { Autocomplete } from "./Autocomplete";</pre>
<p class="translated">现在，我们准备在页面上放置一个自动完成字段。在<code>App()</code>函数的JSX返回值中，我们可以将<code>&lt;Autocomplete /&gt;</code>组件放在对UI有意义的任何地方。我建议放在网页正文之后。</p>
<pre class="lang:javascript decode:true ">export default function App() {  &#13;
    return (  &#13;
      &lt;div className="App"&gt;  &#13;
           &lt;h1 className="text-xl"&gt;  &#13;
             Run JS from{" "}  &#13;
             &lt;a href="https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/autocomplete-js/autocomplete/"&gt;  &#13;
               Autocomplete  &#13;
             &lt;/a&gt;  &#13;
           &lt;/h1&gt;  &#13;
           &lt;p className="text-base"&gt;  &#13;
             This demo is based on the amazing idea of{" "}  &#13;
             &lt;a href="https://twitter.com/frontstuff_io"&gt;Sarah Dayan&lt;/a&gt; in her  &#13;
             appearance on{" "}  &#13;
             &lt;a href="https://www.learnwithjason.dev/javascript-autocomplete"&gt;  &#13;
               Learn with Jason  &#13;
             &lt;/a&gt;  &#13;
             .  &#13;
           &lt;/p&gt;  &#13;
           &lt;p&gt;  &#13;
             Use the Autocomplete box below to toggle dark mode and perform other  &#13;
             JS-driven actions on the page.  &#13;
           &lt;/p&gt;  &#13;
  &#13;
            &lt;Autocomplete /&gt;&#13;
  &#13;
      {/* ... the rest of the function ... */}&#13;
      &lt;/div&gt;&#13;
    )&#13;
  }</pre>
<p class="translated">Autocomplete组件可以接受任何属性，只要这个属性是<code>autocomplete-js</code>库可以接受的选项。首先，让我们添加占位符文本。</p>
<pre class="lang:javascript decode:true ">&lt;Autocomplete placeholder="Try /dark" /&gt;</pre>
<p class="translated">一个搜索字段应该出现在我们的应用程序与占位符文本集。这个字段还没有做任何事情。让我们添加一些数据来完成。</p>
<h2 class="translated"><a id="adding-an-actions-source-to-the-autocomplete-component" class="anchor" href="#adding-an-actions-source-to-the-autocomplete-component" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#adding-an-raw-actions-endraw-source-to-the-autocomplete-component" name="adding-an-raw-actions-endraw-source-to-the-autocomplete-component"/>向自动完成组件添加一个<code>actions</code>源</h2>
<p class="translated">自动完成库能够针对多个源创建自动完成功能。在我们的例子中，我们只有一个静态源，但是任何外部数据——包括Algolia指数——都可以用来填充这个功能。</p>
<p class="translated">要添加一个源，我们将使用<code>getSources</code>属性并提供一个接受<code>query</code>选项的函数。该查询是用户主动输入到输入中的内容。我们可以用它来检查数据中的项目。</p>
<p class="translated">源是getSources返回数组中的对象。我们需要的源的基本元素是一个<code>sourceId</code>字符串、一个用于呈现的<code>template</code>对象和一个返回数据的<code>getItems()</code>函数。现在，我们只返回一个带有标签属性的静态数组。这足以填充我们的自动完成功能。让我们也添加<code>openOnFocus</code>作为道具，当用户聚焦字段时自动列出我们的项目。</p>
<pre class="lang:javascript decode:true ">&lt;Autocomplete  &#13;
  placeholder="Try /dark"&#13;
  openOnFocus   &#13;
  getSources={({ query }) =&gt; [  &#13;
    {  &#13;
      sourceId: "actions",  &#13;
      templates: {  &#13;
        item({ item }) {  &#13;
          return &lt;h3&gt;{item.label}&lt;/h3&gt;  &#13;
        }  &#13;
      },  &#13;
      getItems({ state }) {  &#13;
        return [  &#13;
          {  &#13;
            label: "/dark"  &#13;
          },  &#13;
          {  &#13;
            label: "/light"  &#13;
          }  &#13;
        ]  &#13;
      }  &#13;
    }  &#13;
  ]}  &#13;
/&gt;</pre>
<p class="translated">现在，我们有项目填充我们的领域，但我们不过滤项目，因为我们键入。让我们用几个辅助函数来解决这个问题。</p>
<h2 class="translated"><a id="filtering-and-highlighting-autocomplete-items" class="anchor" href="#filtering-and-highlighting-autocomplete-items" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#filtering-and-highlighting-autocomplete-items" name="filtering-and-highlighting-autocomplete-items"/>过滤并突出显示自动完成的项目</h2>
<p class="translated">当使用Algolia索引时，我们可以使用一些辅助函数来管理过滤和突出显示，但我们没有使用Algolia索引。在我们的用例中，我们希望将它完全保留在浏览器中。为此，我们需要几个助手函数来适当地过滤和突出显示我们的选项。</p>
<h3 class="translated"><a id="filtering-autocomplete-items-with-javascript-regexp" class="anchor" href="#filtering-autocomplete-items-with-javascript-regexp" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#filtering-autocomplete-items-with-javascript-regexp" name="filtering-autocomplete-items-with-javascript-regexp"/>用JavaScript RegExp()过滤自动完成项</h3>
<p class="translated">JavaScript提供了基于正则表达式测试过滤数组的能力。要做到这一点，我们需要创建一个模式来测试用户可能向我们抛出的任何组合。让我们基于查询创建一个助手函数，并在JS <code>.filter()</code>方法中使用它。</p>
<p class="translated">在<code>App.js</code>导出之外，我们将创建新的助手函数<code>getQueryPattern()</code>。</p>
<pre class="lang:javascript decode:true ">function getQueryPattern(query, flags = \"i\") {  &#13;
  const pattern = new RegExp(  &#13;
    `(${query  &#13;
      .trim() // Trim leading and ending whitespace &#13;
      .toLowerCase() // convert to lower case&#13;
      .split(" ") // Split on spaces for multiple commands &#13;
      .map((token) =&gt; `^${token}`) // Map over the resulting array and create Regex_  &#13;
      .join("|")})`, // Join those expressions with an OR | &#13;
    flags  &#13;
  );&#13;
&#13;
  return pattern;  &#13;
}&#13;
&#13;
export default function App() { /* ... */ }</pre>
<p class="translated">一旦创建了helper函数，我们将在返回项目数组之前在<code>getItems()</code>方法中创建模式。</p>
<p class="translated">有了保存的模式，我们可以用它来测试我们的数组。</p>
<pre class="lang:javascript decode:true ">&lt;Autocomplete&#13;
  placeholder="Try /dark"&#13;
  openOnFocus&#13;
  getSources={({ query }) =&gt; [&#13;
    {&#13;
      sourceId: "actions",&#13;
      templates: {&#13;
        item({ item }) {&#13;
          return &lt;h3&gt;{item.label}&lt;/h3&gt;&#13;
        }&#13;
      },&#13;
      getItems({ state }) {&#13;
        const pattern = getQueryPattern(query);&#13;
&#13;
        return [&#13;
          {&#13;
            label: "/dark"&#13;
          },&#13;
          {&#13;
            label: "/light"&#13;
          }&#13;
        ].filter(({ label }) =&gt; pattern.test(label)) // tests the label against the pattern&#13;
      }&#13;
    }&#13;
  ]}&#13;
/&gt;</pre>
<p class="translated">现在，当我们在字段中键入<code>/dark</code>时，只有<code>/dark</code>选项。我们没有给用户任何提示，说明为什么会这样。让我们添加一个小的突出显示功能来展示输入的字母。</p>
<h3 class="translated"><a id="highlighting-the-string-being-typed-in-results" class="anchor" href="#highlighting-the-string-being-typed-in-results" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#highlighting-the-string-being-typed-in-results" name="highlighting-the-string-being-typed-in-results"/>高亮显示结果中正在键入的字符串</h3>
<p class="translated">为了突出显示键入的文本，我们需要获取查询文本和我们在上一步中创建的模式，并生成一个新的字符串，在键入的文本周围添加附加的降价。</p>
<p class="translated">在<code>getQueryPattern</code>助手函数之后，让我们创建一个新的<code>highlight</code>助手函数。</p>
<pre class="lang:javascript decode:true ">function highlight(text, pattern) {&#13;
&#13;
    // Split the text based on the pattern  &#13;
    const tokens = text.split(pattern);&#13;
  &#13;
    // Map over the split text and test against the pattern  &#13;
    return tokens.map((token) =&gt; {&#13;
  &#13;
      // If the pattern matches the text, wrap the text in &lt;mark&gt;  &#13;
      if (!pattern.test("") &amp;&amp; pattern.test(token)) {&#13;
        return &lt;mark&gt;{token}&lt;/mark&gt;;&#13;
      }&#13;
  &#13;
      // return the token back to the array  &#13;
      return token;&#13;
    });&#13;
  }</pre>
<p class="translated">这个helper函数接受要测试的文本和要检查的模式，并返回一个带有附加标记的字符串。</p>
<p class="translated">我们首先根据模式分割文本。这将给我们一个由两部分组成的数组——匹配的和不匹配的。当我们映射这个新数组时，我们可以对照模式检查文本，如果匹配，就用一段新的标记包装这个特定的项。如果没有，返回未修改的文本。</p>
<pre class="lang:javascript decode:true ">&lt;Autocomplete&#13;
  placeholder="Try /dark"&#13;
  openOnFocus&#13;
  getSources={({ query }) =&gt; [&#13;
    {&#13;
      sourceId: "actions",&#13;
&#13;
      templates: {&#13;
        item({ item }) {&#13;
          return &lt;h3&gt;{item.highlighted}&lt;/h3&gt;&#13;
        }&#13;
      },&#13;
&#13;
      getItems({ state }) {&#13;
        const pattern = getQueryPattern(query);&#13;
&#13;
        return [&#13;
          {&#13;
            label: "/dark"&#13;
          },&#13;
          {&#13;
            label: "/light"&#13;
          }&#13;
        ]&#13;
        .filter(({ label }) =&gt; pattern.test(label)) // tests the label against the pattern&#13;
        .map((action) =&gt; ({&#13;
          ...action,&#13;
          highlighted: highlight(action.label, pattern)&#13;
        }));&#13;
      }&#13;
    }&#13;
  ]&#13;
  }&#13;
/&gt;</pre>
<p class="translated">有了这个助手函数，我们现在可以映射所有被过滤的条目。我们将采取行动项目，并返回一个对象及其所有的初始属性，但一个新的<code>highlighted</code>属性，其中包含我们突出显示的文本。这是根据动作的<code>label</code>属性和我们之前定义的模式构建的。</p>
<p class="translated">现在，我们将使用新的<code>highlight</code>属性，而不是在模板中使用<code>action.label</code>。当<code>/dark</code>被输入到字段中时，该项目将有正确的高亮文本。</p>
<p class="translated">过滤UI已经完成，但是当我们选择一个项目时，什么也没有发生。让我们解决这个问题。</p>
<h2 class="translated"><a id="firing-a-javascript-function-in-autocomplete-with-onselect" class="anchor" href="#firing-a-javascript-function-in-autocomplete-with-onselect" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#firing-a-javascript-function-in-autocomplete-with-raw-onselect-endraw-" name="firing-a-javascript-function-in-autocomplete-with-raw-onselect-endraw-"/>用<code>onSelect</code>在自动完成中触发一个JavaScript函数</h2>
<p class="translated">在<code>getSources</code>数组中的每个源可以有自己的<code>onSelect</code>方法。这个方法定义了当用户通过键盘或点击选择一个选项时的功能。</p>
<p class="translated">让我们首先创建一个全局选择函数来记录项目的数据，然后将查询重置为空字符串。</p>
<pre class="lang:javascript decode:true ">getSources = {({ query }) =&gt; [&#13;
    {&#13;
      sourceId: "actions",&#13;
      templates: {&#13;
        item({ item }) {&#13;
          return &lt;h3&gt;{item.highlighted}&lt;/h3&gt;&#13;
        }&#13;
      },&#13;
      // Run this code when item is selected  &#13;
     onSelect(params) {&#13;
        // item is the full item data&#13;
        // setQuery is a hook to set the query state&#13;
        const { item, setQuery } = params;&#13;
        console.log(item)&#13;
        setQuery("");&#13;
      },&#13;
    }</pre>
<p class="translated">对于一个动作，我们可以在这个方法中定义JavaScript，但是为了使这个方法在将来可以被任何动作重用，让我们在项目的数据上定义这个方法。</p>
<p class="translated">为此，我们将为每个项目定义一个名为<code>onSelect</code>的方法。这个方法可以处理您需要的任何功能。在这种情况下，我们将创建一个非常简单的黑暗和光明模式，方法是将类<code>dark</code>添加到主体以启用黑暗模式，并移除它以启用光明模式。</p>
<pre class="lang:javascript decode:true ">{&#13;
  label: "/light",&#13;
  onSelect() {&#13;
    document.querySelector("body").classList.remove("dark");&#13;
    notify("Light Mode enabled");&#13;
  }&#13;
},&#13;
{&#13;
  label: "/dark",&#13;
  onSelect() {&#13;
    document.querySelector("body").classList.add("dark");&#13;
    notify("Dark Mode enabled");&#13;
  }&#13;
},</pre>
<p class="translated">现在，回到主<code>onSelect</code>方法，我们可以运行<code>item.onSelect()</code>，而不是运行<code>console.log(item)</code>。这将启动我们刚刚创建的函数。</p>
<p class="translated">我们现在有功能性的行动！</p>
<h2 class="translated"><a id="enhancing-the-omnibar-experience" class="anchor" href="#enhancing-the-omnibar-experience" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#enhancing-the-omnibar-experience" name="enhancing-the-omnibar-experience"/>增强全方位体验</h2>
<p class="translated">有了工作动作，我们可以专注于为omnibar打造强大的用户体验。</p>
<h3 class="translated"><a id="automatic-highlight-and-select" class="anchor" href="#automatic-highlight-and-select" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#automatic-highlight-and-select" name="automatic-highlight-and-select"/>自动高亮并选择</h3>
<p class="translated">首先，让Autocomplete自动突出显示列表中的第一项。这将允许用户只需按回车键就可以选择一个动作。</p>
<p class="translated">为了添加这个特性，我们需要向<code>&lt;Autocomplete /&gt;</code>组件传递一个新的道具。通过给属性<code>defaultActiveItemId</code>传递一个值<code>"0"</code>，我们可以激活列表中的第一项。任何激活的项目都可以通过按回车键来选择。这带来了坚实的键盘体验。</p>
<h3 class="translated"><a id="creating-a-more-robust-ui-with-a-new-component" class="anchor" href="#creating-a-more-robust-ui-with-a-new-component" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#creating-a-more-robust-ui-with-a-new-component" name="creating-a-more-robust-ui-with-a-new-component"/>使用新组件创建更健壮的UI</h3>
<p class="translated">让我们抽象出<code>template</code>来使用一个叫做<code>Action</code>的独立组件。我们可以在一个单独的文件中构建它，或者在<code>App.js</code>中创建它。</p>
<p class="translated">为了使用该组件，我们将向它传递一个包含我们的项目数据的<code>hit</code>属性。该组件还将使用特定的类名，这些类名与我们在本教程开始时导入的经典主题中的特定项目相匹配。</p>
<p class="translated">在标记内部，我们提供了突出显示的文本和两个新项:<code>hit.icon</code>和return键的SVG表示。这增加了一些定制的图标</p>
<pre class="lang:javascript decode:true ">function Action({ hit }) {&#13;
    // Component to display the items  &#13;
    return (&#13;
      &lt;div className="aa-ItemWrapper"&gt;&#13;
        &lt;div className="aa-ItemContent"&gt;&#13;
          &lt;div className="aa-ItemIcon"&gt;{hit.icon}&lt;/div&gt;&#13;
          &lt;div className="aa-ItemContentBody"&gt;&#13;
            &lt;div className="aa-ItemContentTitle"&gt;&#13;
              &lt;span&gt;{hit.highlighted}&lt;/span&gt;&#13;
            &lt;/div&gt;&#13;
          &lt;/div&gt;&#13;
        &lt;/div&gt;&#13;
        &lt;div className="aa-ItemActions"&gt;&#13;
          &lt;button&#13;
            className="aa-ItemActionButton aa-DesktopOnly aa-ActiveOnly"&#13;
            type="button"&#13;
            title="Select"&#13;
          &gt;&#13;
            &lt;svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"&gt;&#13;
              &lt;path d="M18.984 6.984h2.016v6h-15.188l3.609 3.609-1.406 1.406-6-6 6-6 1.406 1.406-3.609 3.609h13.172v-4.031z" /&gt;&#13;
            &lt;/svg&gt;&#13;
          &lt;/button&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
    );&#13;
  }</pre>
<p class="translated">一旦组件被创建，我们需要改变我们的<code>item</code>模板来使用它。</p>
<pre class="lang:javascript decode:true ">templates: {&#13;
    item({ item }) {&#13;
      return &lt;Action hit={item} /&gt;;&#13;
    }&#13;
  }</pre>
<p class="translated">我们还需要为每个操作项添加一个图标属性。在这个例子中，我们有一些手工制作的SVG，但是任何图标库都可以。</p>
<pre class="lang:javascript decode:true ">return [&#13;
    {&#13;
      icon: (&#13;
        &lt;svg fill="none" viewBox="0 0 24 24" stroke="currentColor"&gt;&#13;
          &lt;path&#13;
            strokeLinecap="round"&#13;
            strokeLinejoin="round"&#13;
            strokeWidth={2}&#13;
            d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"&#13;
          /&gt;&#13;
        &lt;/svg&gt;&#13;
      ),&#13;
      label: "/dark",&#13;
      enabled: state.context.dark,&#13;
      onSelect({ setContext }) {&#13;
        document.querySelector("body").classList.add("dark");&#13;
      }&#13;
    },&#13;
    {&#13;
      icon: (&#13;
        &lt;svg fill="none" viewBox="0 0 24 24" stroke="currentColor"&gt;&#13;
          &lt;path&#13;
            strokeLinecap="round"&#13;
            strokeLinejoin="round"&#13;
            strokeWidth={2}&#13;
            d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"&#13;
          /&gt;&#13;
        &lt;/svg&gt;&#13;
      ),&#13;
      label: "/light",&#13;
      onSelect() {&#13;
        document.querySelector("body").classList.remove("dark");&#13;
        notify("Light Mode enabled");&#13;
      }&#13;
    },&#13;
  ]</pre>
<p class="translated">这看起来真的很不错。有点奇怪的是，该网站是在光模式，但光模式选项没有提供这方面的指示。让我们为我们的用户添加一些上下文。</p>
<h3 class="translated"><a id="creating-an-enabled-state-with-setcontext" class="anchor" href="#creating-an-enabled-state-with-setcontext" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#creating-an-enabled-state-with-raw-setcontext-endraw-" name="creating-an-enabled-state-with-raw-setcontext-endraw-"/>用<code>setContext</code>创建启用状态</h3>
<p class="translated">自动完成使我们能够访问状态。让我们用它来创建一个<code>enabled</code>状态，并在我们的动作被触发时设置这个状态。</p>
<p class="translated">让我们从给每个名为<code>enabled</code>的动作添加一个新属性开始。</p>
<pre class="lang:javascript decode:true ">{ //...&#13;
  label: "/dark",&#13;
  enabled: state.context.dark,&#13;
  // ...&#13;
},&#13;
{ //...&#13;
  label: "/light",&#13;
  enabled: !state.context.dark,&#13;
  // ...&#13;
}</pre>
<p class="translated">该属性将检查Autocomplete的state对象中是否有标记为<code>dark</code>的上下文项。如果<code>dark</code>设置为<code>true</code>，暗动作将为真<code>enabled</code>状态，如果<code>false</code>，亮将为真。</p>
<p class="translated">为了获得上下文，我们需要在我们的<code>onSelect</code>函数中设置应用程序的上下文。我们可以将<code>setContext</code>方法传递给我们的<code>onSelect</code>函数，并使用它将<code>dark</code>设置为真或假。</p>
<p class="translated">我们需要为sources方法传递options对象中的<code>setContext</code>方法。从将<code>getSources={({ query })}</code>改为<code>getSources={({ query, setContext })}</code>开始。然后我们可以在我们的<code>onSelect</code>函数中使用<code>setContext</code>。</p>
<pre class="lang:javascript decode:true ">onSelect({ setContext }) {&#13;
  document.querySelector("body").classList.remove("dark");&#13;
  setContext({ dark: false });&#13;
}</pre>
<p class="translated">现在剩下的就是在我们的组件中使用<code>enabled</code>布尔值。</p>
<pre class="lang:javascript decode:true ">function Action({ hit }) {&#13;
    // Component to display the items&#13;
    return (&#13;
      &lt;div className="aa-ItemWrapper"&gt;&#13;
        &lt;div className="aa-ItemContent"&gt;&#13;
          &lt;div className="aa-ItemIcon"&gt;{hit.icon}&lt;/div&gt;&#13;
          &lt;div className="aa-ItemContentBody"&gt;&#13;
            &lt;div className="aa-ItemContentTitle"&gt;&#13;
              &lt;span&gt;{hit.highlighted}&lt;/span&gt;&#13;
              {hit.enabled &amp;&amp; (&#13;
                &lt;code className="aa-ItemContentTitleNote"&gt;Enabled&lt;/code&gt;&#13;
              )}&#13;
            &lt;/div&gt;&#13;
          &lt;/div&gt;&#13;
        &lt;/div&gt;&#13;
        &lt;div className="aa-ItemActions"&gt;&#13;
          &lt;button&#13;
            className="aa-ItemActionButton aa-DesktopOnly aa-ActiveOnly"&#13;
            type="button"&#13;
            title="Select"&#13;
          &gt;&#13;
            &lt;svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"&gt;&#13;
              &lt;path d="M18.984 6.984h2.016v6h-15.188l3.609 3.609-1.406 1.406-6-6 6-6 1.406 1.406-3.609 3.609h13.172v-4.031z" /&gt;&#13;
            &lt;/svg&gt;&#13;
          &lt;/button&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
    );&#13;
  }</pre>
<p class="translated">因此，我们的omnibar是有状态的。这是黑暗模式的一个相对简单的例子。为了更好地构建它，您可以从应用程序的整体状态或者基于用户的本地存储中的信息来添加和设置omnibar的上下文。</p>
<h2 class="translated"><a id="next-steps" class="anchor" href="#next-steps" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-2ko5-temp-slug-9942710?preview=ddb4048d0bb2325f5214dfc1533ce0f50aa1c867476c7ddd1b7c781ec759924bd97e1e1992acc3d2c47cf0a122119a1e7962fcab3d39c7d0cd56ab23#next-steps" name="next-steps"/>下一步</h2>
<p class="translated">在本教程中，我们构建了不仅仅是搜索的Autocomplete，但是您也可以使用不同的源对象和它自己的一组模板来添加常规的搜索功能。您还可以扩展这些操作，以匹配应用程序具有的任何潜在操作。</p>
<p class="translated">一些想法:</p>
<ul>
<li class="translated">添加到待办事项列表或已保存列表</li>
<li class="translated">时事通讯注册</li>
<li class="translated">用户配置文件更新</li>
</ul>
<p class="translated">我们很想看看你有什么想法。分叉<a href="https://alg.li/omnibar-starter">启动沙箱</a>(或者<a href="https://codesandbox.io/s/autocomplete-actions-finished-eh7xw">这个完成了一个</a>)，创造一些新的东西，然后<a href="https://twitter.com/algolia">在Twitter </a>上和我们分享。在我们的开源代码交换平台上查看相关解决方案。</p>
<p class="translated"><a class="aligncenter" href="https://www.algolia.com/developers/code-exchange/?page=1&amp;refinementList%5Bproduct_features%5D%5B0%5D=Autocomplete"> <img loading="lazy" class="wp-image-13777" src="../Images/7665551c18b687f25dcadc15cb213b7d.png" alt="" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2022/01/CodeX@2x.png"/> </a></p>
</div></div>    
</body>
</html>