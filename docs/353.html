<html>
<head>
<title>Ruby Client v2 is out! - Algolia Blog | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby客户端v2发布了！-阿尔戈利亚博客|阿尔戈利亚博客</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/ruby-client-v2-is-out/#0001-01-01">https://www.algolia.com/blog/engineering/ruby-client-v2-is-out/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="translated">Algoliasphere的好消息:我们刚刚发布了Ruby客户端的一个新的主要版本。 <span>你知道Ruby客户端是我们设计的第一个吗？1.1.3版本差不多七年前就出了！退一步说，T4的确值得拥有一些新鲜空气。这个新版本获得了全新的设计，为您带来了大量新功能，同时100%符合通用API客户端规范</span><a href="https://blog.algolia.com/release-api-client-specifications-common-test-suite/"><span/></a><span>。我们来深究一下。</span></p>
<p> </p>
<h2 class="translated"><a id="algoliasearch-becomes-algolia" class="anchor" href="#algoliasearch-becomes-algolia" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a><span>Algolia search变成Algolia </span></h2>
<p class="translated"><span>你可能注意到的第一件事是，我们更改了宝石的名称。我们的Ruby客户端现在提供了几个截然不同的客户端，针对Algolia的不同特性:</span> <a href="https://www.algolia.com/doc/rest-api/search/"> <span>搜索</span> </a> <span>当然，还有</span> <a href="https://www.algolia.com/doc/rest-api/analytics/"> <span>分析</span></a><span/><a href="https://www.algolia.com/doc/rest-api/insights/"><span>见解</span> </a> <span>，以及</span> <a href="https://www.algolia.com/doc/rest-api/recommend/"> <span>推荐</span> </a> <span>。由于这一变化，gem反映新的架构并将其简单地重命名为“algolia”是有意义的。</span></p>
<p class="translated"><span>使用我们的整个REST API的全部潜力现在是小菜一碟，因为您只需实例化您选择的客户端并使用我们为您量身定制的端点。他们都依赖于我们的重试策略来为您提供最佳体验(稍后将详细介绍)</span></p>
<p class="translated"><img loading="lazy" class="aligncenter size-large wp-image-11038" src="../Images/f249c7b4fd8464a0906872859ab8d5d4.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2020/11/image2-720x375.png 720w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image2-320x166.png 320w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image2-768x400.png 768w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image2.png 1138w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2020/11/image2-720x375.png"/></p>
<p> </p>
<h2 class="translated"><a id="modern-tooling" class="anchor" href="#modern-tooling" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>现代工装</span></h2>
<p class="translated">我们利用改造的机会在Ruby社区中使用了最先进的工具。<a href="https://github.com/ruby/rake" target="_blank" rel="noopener noreferrer"><span/></a><span>任务处理测试和林挺。林挺是用</span><a href="https://rubocop.org/" target="_blank" rel="noopener noreferrer"><span>rubo COP</span></a><span>完成的，测试用</span><a href="https://github.com/seattlerb/minitest" target="_blank" rel="noopener noreferrer"><span>Minitest</span></a><span>。我们选择Minitest而不是Rspec的原因很简单:它是唯一一个提供并行测试可能性的工具。我们希望确保我们的客户端与JRuby兼容，这样多线程就不会被忽略，Minitest并行测试向我们保证一切都会顺利进行。此外，所有方法都使用</span> <a href="https://yardoc.org/" target="_blank" rel="noopener noreferrer"> <span>码</span> </a> <span>约定进行记录。</span></p>
<p class="translated"><span>支持的最低Ruby版本是2.2。这是一个仍然在我们的用户中广泛使用的版本，也是Rails早期版本v5中支持最少的Ruby版本。</span></p>
<p> </p>
<h2 class="translated"><a id="fully-independent-retry-strategy" class="anchor" href="#fully-independent-retry-strategy" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>完全独立重试策略</span></h2>
<p class="translated"><span>为了给你最好的Algolis体验，并为你提供一个强大的客户端，我们现在实施与我们所有其他客户端相同的重试策略。它是确保最大服务可用性的关键元素，因为它是作为单独的类实现的，所以它已经过彻底的单元测试，可以作为一个系统独立工作。这也意味着您可以在我们所有不同的客户端实例中受益，甚至在您决定不使用我们捆绑的HTTP客户端的情况下。因为是的，您可以自由地使用您喜欢的任何HTTP客户端！</span></p>
<p> </p>
<h2 class="translated"><a id="diy-client" class="anchor" href="#diy-client" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span> DIY客户端</span></h2>
<p class="translated">这个客户端很容易定制。当我们构建API客户端时，最重要的是可靠性和开发者体验(DX)。我们希望您能够放心地使用我们的服务，而且是以您感觉最舒适的方式使用。在这种情况下，您可以覆盖我们的请求者，您可以覆盖我们的记录器，如果您选择继续使用我们提供的请求者， <a href="https://lostisland.github.io/faraday/" target="_blank" rel="noopener noreferrer"> <span>【法拉第</span> </a> <span>，您也可以覆盖您将与之一起使用的适配器。这就是我们选择Faraday作为默认HTTP库的原因。它不仅易于实现，而且广受欢迎并经常更新，</span> <i> <span>和</span> </i> <span>它满足了我们旨在为您提供的灵活性需求。我们附带的默认适配器是Nett:Http:Persistent，但是您可以很容易地将其转换为您最喜欢的Http库(Excon、HTTPClient或httpx，仅举几个例子)。</span></p>
<p class="translated"><img loading="lazy" class="aligncenter size-large wp-image-11039" src="../Images/6893ddc49fa1bd1480f9bed088ebcc32.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2020/11/image4-720x170.png 720w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image4-320x75.png 320w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image4-768x181.png 768w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image4.png 1442w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2020/11/image4-720x170.png"/></p>
<p> </p>
<h2 class="translated"><a id="request-options" class="anchor" href="#request-options" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>请求选项</span></h2>
<p class="translated">我们简化了处理可选参数的方式。现在，方法签名中只需要强制参数，其他的都可以在最后一个可选参数中作为散列传递。如果要传递头、超时、connect_timeout或compression_type，必须显式设置它们。剩下的可以照原样通过！它缩短了方法签名，也与我们的其他动态类型客户端保持一致，如 <a href="https://github.com/algolia/algoliasearch-client-python" target="_blank" rel="noopener noreferrer"> <span> Python </span> </a> <span>或</span> <a href="https://github.com/algolia/algoliasearch-client-php" target="_blank" rel="noopener noreferrer"> <span> PHP </span> </a> <span>。</span></p>
<p class="translated"><img loading="lazy" class="aligncenter size-large wp-image-11040" src="../Images/c24c15a7b13b19ffc3ad1143565a7ece.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2020/11/image1-673x400.png 673w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image1-300x178.png 300w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image1-768x456.png 768w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image1.png 936w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2020/11/image1-673x400.png"/></p>
<p class="translated"><img loading="lazy" class="aligncenter size-large wp-image-11041" src="../Images/3fb8dd34674b4896d2dfbcdddaa8cb5c.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2020/11/image7-720x295.png 720w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image7-320x131.png 320w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image7-768x315.png 768w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image7.png 918w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2020/11/image7-720x295.png"/></p>
<p> </p>
<h2 class="translated"><a id="standalone-configuration" class="anchor" href="#standalone-configuration" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>单机配置</span></h2>
<p class="translated">我们已经为配置添加了专门的类。您可以在这里为每个客户端设置超时、头和特定配置。这些配置过去是直接在客户机中设置的，但现在它们有了专用的类，使它们更容易调整，并分离了它所属的客户机各个方面的逻辑。例如，您可以覆盖搜索配置中的默认主机。</p>
<p class="translated"><img loading="lazy" class="aligncenter size-large wp-image-11042" src="../Images/ed2cb72f8accac18a8f061ab4d3ff648.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2020/11/image5-720x301.png 720w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image5-320x134.png 320w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image5-768x322.png 768w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image5.png 1070w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2020/11/image5-720x301.png"/></p>
<p> </p>
<h2 class="translated"><a id="search-client" class="anchor" href="#search-client" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>搜索客户端</span></h2>
<p class="translated"><span>搜索客户端类已清理完毕。除了单独处理配置之外，我们还删除了协议类:现在您可以直接在主类中读取被访问的端点，并更好地了解幕后发生了什么。最重要的是，它不再是单例实例:通过传递应用ID和API键来创建客户机。这个实例将在其请求者和连接池上运行，不会干扰同时运行的任何其他实例。</span></p>
<p class="translated"><img loading="lazy" class="aligncenter size-large wp-image-11043" src="../Images/57c8ffdfbcbf01822b541df41da0becc.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2020/11/image6-720x310.png 720w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image6-320x138.png 320w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image6-768x331.png 768w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image6.png 1374w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2020/11/image6-720x310.png"/></p>
<p> </p>
<h2 class="translated"><a id="search-index" class="anchor" href="#search-index" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>搜索索引</span></h2>
<p class="translated">搜索索引类别大部分保持不变。正如我们之前提到的，主要的改进是通过将所有可选参数放在一个散列中来缩短方法的签名。因为这是一个非常受欢迎的特性，所以我们保留了bang方法，让您等待整个操作完成。您也可以像我们在其他客户端中所做的那样，在您的调用之后链接“wait()”方法。</p>
<p class="translated"><img loading="lazy" class="aligncenter size-large wp-image-11044" src="../Images/839f590c891608e49874dcbc60084ced.png" alt="" srcset="https://blog-api.algolia.com/wp-content/uploads/2020/11/image3-720x251.png 720w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image3-320x112.png 320w, https://blog-api.algolia.com/wp-content/uploads/2020/11/image3.png 768w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2020/11/image3-720x251.png"/></p>
<p> </p>
<h2 class="translated"><a id="tldr" class="anchor" href="#tldr" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16">T5</svg>T7<span>TL；博士</span></a></h2>
<p class="translated"><span>我们摆脱了当前Ruby客户端的主要痛点，搜索客户端的单一实例，以及我们的Ruby客户端与我们的通用规范不一致的事实。我们现在有了一个新的基础，它符合Algolia标准、Ruby标准，并遵循CTS进行额外的单元测试。我们希望您会像我们喜欢构建v2一样喜欢使用它！如果您想获得所有更改的详尽列表，请参考我们的</span> <a href="https://www.algolia.com/doc/api-client/getting-started/update/ruby/?client=ruby"> <span>升级指南</span> </a> <span>。</span></p>
<p class="translated"><span>感谢您的阅读！</span></p>
</div></div>    
</body>
</html>