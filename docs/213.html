<html>
<head>
<title>Pest, a simple &amp; elegant testing framework for PHP that extends PHPUnit | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pest，一个简单而优雅的PHP测试框架，它扩展了PHPUnit | Algolia Blog</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/pest-a-testing-framework-that-goes-above-and-beyond-phpunit/#0001-01-01">https://www.algolia.com/blog/engineering/pest-a-testing-framework-that-goes-above-and-beyond-phpunit/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="translated">构建第三方API时，在你见过或能预见的每一个运行时场景中测试你的代码是很重要的。为此，一个健壮且易于使用的&amp;维护测试框架是必须的。作为PHP开发人员，我们严重依赖于<a href="https://phpunit.de/"> PHPUnit </a>，但是我们切换到了<a href="https://pestphp.com/">害虫测试框架</a>，这简化并减少了我们庞大的测试代码库。</p>
<p class="translated">鉴于我们执行的测试数量，并试图覆盖我们代码库中的每个功能，我们需要简化测试代码，使其更易于维护、理解和调试。我们还想确保我们的测试框架需要很少的努力就能集成到Laravel中。</p>
<p class="translated"><span>在本文中，我们来看看</span> Pest <span>，这是一个健壮的测试框架，构建在PHP的标准测试库PHPUnit之上。</span></p>
<h2 class="translated"><a id="reducing-the-testing-code-base-of-phpunit-with-php-chaining" class="anchor" href="#reducing-the-testing-code-base-of-phpunit-with-php-chaining" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>用PHP链接减少PHPUnit的测试代码库</span></h2>
<p class="translated"><span>部分受<a href="https://relishapp.com/rspec/rspec-core/docs/subject/one-liner-syntax"> Ruby Rspec </a> </span> <span>中单行代码“it”语法的启发，Pest自己的语法相当简单。Pest去掉了PHPUnit中需要的命名空间和库引用，不需要</span> <i> <span>扩展</span> </i> <span>上百个函数。它只需要你指定测试函数——使维护和调试变得容易得多:</span></p>
<pre class="lang:php decode:true">it('is an example, function () {&#13;
    assertTrue(true);&#13;
});&#13;
</pre>
<p class="translated">尽管如此，3行代码乘以100次测试可能还是太多了。Pest允许你 <i> <span>连锁</span> </i> <span>的功能。结果是一个liner: </span></p>
<pre class="lang:php decode:true">it('is an example', function ()-&gt;assertTrue(true);&#13;
</pre>
<p class="translated"><span>因此，Pest将PHPUnit下面的8行代码缩减为上面的1行代码:</span></p>
<pre class="lang:php decode:true">namespace Tests\Unit;&#13;
use PHPUnit\Framework\TestCase;&#13;
&#13;
class ExampleTest extends TestCase&#13;
{&#13;
    /** @test */&#13;
    public function testBasicTest()&#13;
    {&#13;
        $this-&gt;assertTrue(true);        &#13;
    } &#13;
    // ...&#13;
}&#13;
</pre>
<h2 class="translated"><a id="improving-the-output" class="anchor" href="#improving-the-output" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>提高输出</span></h2>
<p class="translated"><span> PHPUnit为PHP用户提供了以非常简洁的方式可视化测试结果的能力:</span></p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-14004" src="../Images/8a7b8e03d6d3ed246d1365715e65cabb.png" alt="phpunit testing output" srcset="https://blog-api.algolia.com/wp-content/uploads/2022/02/phpunit-output-320x154.png 320w, https://blog-api.algolia.com/wp-content/uploads/2022/02/phpunit-output-720x347.png 720w, https://blog-api.algolia.com/wp-content/uploads/2022/02/phpunit-output-768x370.png 768w, https://blog-api.algolia.com/wp-content/uploads/2022/02/phpunit-output.png 1062w" sizes="(max-width: 678px) 100vw, 678px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2022/02/phpunit-output-320x154.png"/></p>
<p class="translated"><span>虽然简洁通常是好的，但我们觉得我们需要更多。Pest为我们提供了每次测试的更多信息:</span></p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-14002" src="../Images/607278021c0aca50c71aa8a9aeacd1c0.png" alt="pest testing output " srcset="https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-output-320x146.png 320w, https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-output-720x329.png 720w, https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-output-768x351.png 768w, https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-output.png 1104w" sizes="(max-width: 684px) 100vw, 684px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-output-320x146.png"/></p>
<p class="translated"><span>对于错误，Pest允许您直接访问失败的代码行:</span></p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-14001" src="../Images/ef72884806aee8a30b75fc0ca5caafe9.png" alt="pest testing output failure" srcset="https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-failure-output-222x178.png 222w, https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-failure-output-498x400.png 498w, https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-failure-output-768x617.png 768w, https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-failure-output.png 792w" sizes="(max-width: 692px) 100vw, 692px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-failure-output-222x178.png"/></p>
<p class="translated"><span>最后，如果您想显示已经测试和执行的源代码行数，您可以从<code>coverage</code>选项中获得更多信息:</span></p>
<p class="translated"><img loading="lazy" class="alignnone wp-image-14003" src="../Images/7b084ffac03c049e208be82cf71a9cbc.png" alt="pest testing output verbose" srcset="https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-verbose-310x178.png 310w, https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-verbose-696x400.png 696w, https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-verbose-768x442.png 768w, https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-verbose-1536x883.png 1536w, https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-verbose.png 1826w" sizes="(max-width: 691px) 100vw, 691px" data-original-src="https://blog-api.algolia.com/wp-content/uploads/2022/02/pest-verbose-310x178.png"/></p>
<h2 class="translated"><a id="adding-scalability-with-datasets" class="anchor" href="#adding-scalability-with-datasets" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>添加数据集的可扩展性</span></h2>
<p class="translated">与大多数测试一样，数据的质量是关键。除了使用真实和相关的模拟内容，测试质量数据还需要:</p>
<ul>
<li aria-level="1" class="translated"><span>对数据的大小变化进行多重测试</span></li>
<li aria-level="1" class="translated"><span>无需任何重新编码即可添加新用例的能力</span></li>
</ul>
<p class="translated"><span>使用Pest的“数据集”，您可以创建一个测试，该测试采用一个</span> <i> <span>内联</span> </i> <span>数据数组。例如，您可以测试多封电子邮件，每封代表一个不同的用例(可能是连接性):</span></p>
<pre class="lang:php decode:true">it('has emails', function ($email) {&#13;
   expect($email)-&gt;not-&gt;toBeEmpty();&#13;
})-&gt;with([&#13;
   'someone@jmail.com',&#13;
   'other@example.com'&#13;
]);&#13;
</pre>
<p class="translated"><span>你也可以使用多维数组:</span></p>
<pre class="lang:php decode:true">it('has emails', function ($name, $email) {&#13;
   expect($email)-&gt;not-&gt;toBeEmpty();&#13;
})-&gt;with([&#13;
   ['Someone', 'someone@jmail.com'],&#13;
   ['Other', 'other@example.com']&#13;
]);&#13;
</pre>
<p class="translated">内联就是这么做的。您还可以将数据移出测试以获得更大的灵活性，为此，您将需要以下文件夹结构:</p>
<pre class="lang:php decode:true">—Tests&#13;
—---testemails.php&#13;
—Datasets&#13;
—---emails.php &#13;
</pre>
<p class="translated"><span>测试函数放在文件夹<code>Tests</code>中，数据集定义在<code>Datasets</code>文件夹中的单个文件中。下面是数据集文件<code>emails.php</code>的内容示例，它替换了上面的内联电子邮件引用:</span></p>
<pre class="lang:php decode:true">dataset('emails', function () {&#13;
   Return (['other@example.com', 'enunomaduro@gmail.com'];&#13;
]);&#13;
</pre>
<p class="translated"><span>因此测试函数现在可以重用<code>emails.php</code>进行测试:</span></p>
<pre class="lang:php decode:true">it('has emails', function ($email) {&#13;
   expect($email)-&gt;not-&gt;toBeEmpty();&#13;
   assertTrue(true);&#13;
})-&gt;with('emails');&#13;
</pre>
<h2 class="translated"><a id="and-more" class="anchor" href="#and-more" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> <span>还有更多</span></h2>
<p class="translated"><span>还有许多额外的特性和选项，以及许多断言、期望和异常。不要忘记，Pest是PHPUnit的扩展，所以您可以在测试之前和之后执行操作，就像PHPUnit中的<code>setup</code>。</span></p>
<p class="translated">这里是最后一个例子。您可以<code>skip</code>测试:</p>
<pre class="lang:php decode:true">it('has home', function () {&#13;
   // ..&#13;
})-&gt;skip();&#13;
</pre>
<p class="translated"><span><code>skip</code>函数向您展示了Pest是如何看待测试人员的，并简化了重要的事情。我建议你不要“跳过”Pest——它真的是PHP生态系统的一大亮点。</span></p>
<p class="translated"><span>了解更多</span> <a href="https://pestphp.com/"> <span>害虫</span> </a> <span>，由</span><a href="https://twitter.com/enunomaduro"><span>Nuno Maduro</span></a>from<span/><a href="https://github.com/laravel"><span>@ laravel</span></a><span>。</span></p>
</div></div>    
</body>
</html>