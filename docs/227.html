<html>
<head>
<title>Kubernetes best practices – a blast (radius) from the past | Algolia Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes最佳实践-来自过去的爆炸(radius )</h1>
<blockquote>原文：<a href="https://www.algolia.com/blog/engineering/8-algolia-tested-best-practices-kubernetes/#0001-01-01">https://www.algolia.com/blog/engineering/8-algolia-tested-best-practices-kubernetes/#0001-01-01</a></blockquote><div><div class="css-t54cg4"><p class="translated">我们大约在四年前开始使用Kubernetes。我们有新的服务要部署，即使我们是裸机的大用户，我们也需要更多的灵活性。因此，我们决定在新系统上测试和使用Kubernetes。两年后，我们的大多数产品都部署在Kubernetes上，遵循Kubernetes的最佳实践。随着越来越多的团队开始在内部使用它，我们创建了一个内部培训。今天，我们很自豪地<a href="https://github.com/algolia/kubernetes-hands-on">将这个培训开源</a>，这样任何人都可以从中学习并做出贡献。</p>
<p class="translated">实施两年后，我们从培训中提取了八个实践，我们认为这八个实践是正确使用Kubernetes的关键。我们重新发布这些Kubernetes最佳实践，作为过去的一个亮点，并为未来关于我们和Kubernetes在过去两年中如何发展的文章奠定基础。</p>
<h2 class="translated"><a id="1-do-not-use-root-user-in-your-containers" class="anchor" href="#1-do-not-use-root-user-in-your-containers" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> 1。不要在容器中使用root用户</h2>
<p class="translated">容器范式，以及它在Linux上的实现方式，并没有考虑到安全性。它的存在只是为了限制资源，比如CPU和RAM，就像Docker <a href="https://docs.docker.com/engine/security/security/" target="_blank" rel="noopener">的文档解释</a>一样。这意味着你的容器不应该使用“根”用户来运行命令。在容器中运行程序与在主机上运行程序几乎是一样的。如果你有兴趣了解更多，<a href="https://medium.com/@mccode/processes-in-containers-should-not-run-as-root-2feae3f0df3b" target="_blank" rel="noopener">查看这篇文章</a>了解原因。</p>
<p class="translated">因此，在所有图像上添加这些行，使您的应用程序由专门的用户运行。将“appuser”替换为与您更相关的名称。</p>
<pre>ARG USER=appuser # set ${USER} to be appuser
addgroup -S ${USER} &amp;&amp; adduser -S ${USER} -G ${USER} # adds a group and a user of it
USER ${USER} # set the user of the container
WORKDIR /home/${USER} # set the workdir to be the home directory of the user
</pre>
<p class="translated">这也可以通过<a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" target="_blank" rel="noopener"> pod安全策略</a>在集群级别得到保证。</p>
<h2 class="translated"><svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg>  2。处理“SIGTERM”信号</h2>
<p class="translated">每当Kubernetes想要优雅地停止一个容器时，它就发送“SIGTERM”信号。您应该监听它，并在应用程序中做出相应的反应(通过关闭连接、保存状态等)。)一般来说，遵循<a href="https://12factor.net/" target="_blank" rel="noopener">十二因素应用</a>建议被认为是良好的实践。另外，不要忘记在您的pod上配置<a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#hook-handler-execution" target="_blank" rel="noopener"> <code>terminationGracePeriodSeconds</code> </a>。默认值是30秒，但是您的应用程序可能需要更多(或更少)的时间来正确终止。</p>
<h2 class="translated"><a id="3-use-a-declarative-management-for-your-manifests" class="anchor" href="#3-use-a-declarative-management-for-your-manifests" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> 3。对您的清单使用声明式管理</h2>
<p class="translated">使用声明性清单，这样可以有效地回滚代码和基础结构。这意味着您的源代码版本应该是您的清单的真实来源。</p>
<p class="translated">这意味着您只使用<code>kubectl apply</code>来更新或创建您的Kubernetes资源，但也意味着您不使用<code>latest</code>标签作为您的图像容器。容器的每个版本都应该是独一无二的，使用Git散列是一个很好的实践。当部署应用程序的新版本时，应该通过为容器指定新版本来更新清单，然后在源代码控制中提交清单，最后运行<code>kubectl apply</code>。</p>
<h2 class="translated"><a id="4-lint-your-manifests" class="anchor" href="#4-lint-your-manifests" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> 4。Lint你的清单</h2>
<p class="translated">YAML是一个<a href="https://docs.saltstack.com/en/latest/topics/troubleshooting/yaml_idiosyncrasies.html" target="_blank" rel="noopener">棘手的格式</a>。我们使用<a href="https://github.com/adrienverge/yamllint" target="_blank" rel="noopener"> yamllint </a>，因为它支持单个文件中的多文档。</p>
<p class="translated">你也可以使用Kubernetes-specifics棉绒:</p>
<ul>
<li class="translated"><a href="https://github.com/zegl/kube-score" target="_blank" rel="noopener"> kube-score </a>检查您的货物清单，并强制执行良好做法。</li>
<li class="translated">kubeval 也检查清单，但是只检查有效性。</li>
</ul>
<p class="translated">在Kubernetes 1.13中，<a href="https://kubernetes.io/blog/2019/01/14/apiserver-dry-run-and-kubectl-diff/" target="_blank" rel="noopener"> <code>--dry-run</code>选项出现在<code>kubectl</code> </a>上，它让Kubernetes检查您的清单而不应用它们。您可以使用此功能来检查您的YAML文件对于Kubernetes是否有效。</p>
<h2 class="translated"><a id="5-configure-the-liveness-and-readiness-probes" class="anchor" href="#5-configure-the-liveness-and-readiness-probes" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> 5。配置活动和就绪探测器</h2>
<p class="translated">活性和就绪性是应用程序向Kubernetes传达其健康状况的方式。配置这两者有助于Kubernetes正确处理您的pod，并对状态变化做出相应的反应。</p>
<p class="translated">活性探测器在这里评估容器是否仍然是活性的；也就是说，如果容器没有处于中断状态、死锁或任何类似的状态。从那里，它可以作出决定，如重新启动它。</p>
<p class="translated">准备就绪探测器在这里检测容器是否准备好接受流量、阻止首次展示、影响Pod中断预算(PDB)等。当您的容器被Kubernetes设置为接收外部流量时(大多数情况下，当它是一个API时)，它特别有用。</p>
<p class="translated">通常，具有相同的就绪性和活性探针是可以接受的。但是在某些情况下，您可能希望它们有所不同。一个很好的例子是运行接受HTTP调用的单线程应用程序(如PHP)的容器。假设您有一个需要很长时间处理的请求。您的应用程序不能接收任何其他请求，因为它被传入的请求阻塞了；因此它还没有“准备好”。另一方面，它正在处理一个请求，因此它是“活动的”。</p>
<p class="translated">另一件要记住的事情是，您的探测器不应该调用您的应用程序的依赖服务。这可以防止级联故障。</p>
<h2 class="translated"><svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg>  6。配置资源请求和限制</h2>
<p class="translated">Kubernetes允许您配置pods资源的“请求”和“限制”(CPU、RAM和磁盘)。配置“请求”有助于Kubernetes更容易地调度您的pod，并更好地在您的节点上打包工作负载。</p>
<p class="translated">大多数时候你可以定义<code>"request" = "limit"</code>。但是要小心，因为你的吊舱将被终止，如果它超过了<code>limit</code>。</p>
<p class="translated">除非您的应用程序被设计为使用多个内核，否则最佳实践通常是将CPU请求保持在<code>"1"</code>或更低。</p>
<h2 class="translated"><a id="7-specify-pod-anti-affinity" class="anchor" href="#7-specify-pod-anti-affinity" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> 7。指定pod反关联性</h2>
<p class="translated">当您部署一个具有大量副本的应用程序时，您很可能希望它们均匀地分布在Kubernetes集群的所有节点上。如果你所有的豆荚都在同一个节点上运行，而这个节点死了，这将杀死你所有的豆荚。为您的部署指定一个pod反关联性可以确保Kubernetes跨所有节点调度您的pod。</p>
<p class="translated">一个好的做法是在节点的主机名上指定一个<code>podAntiAffinity</code>:</p>
<pre>apiVersion: apps/v1
kind: Deployment
metadata:
 name: my-application
spec:
 replicas: 2
 selector:
   matchLabels:
     app: my-application
 template:
   metadata:
     labels:
       app: my-application
   spec:
     containers:
     - name: my-pod
       image: my-image:my-version
     affinity:
       podAntiAffinity:
         preferredDuringSchedulingIgnoredDuringExecution:
           - labelSelector:
               matchExpressions:
                 - key: app
                   operator: In
                   values:
                     - app: my-deployment
             topologyKey: kubernetes.io/hostname
</pre>
<p class="translated">这里我们有一个带有两个副本的部署“我的应用程序”，我们指定了一个带有软需求的<code>podAntiAffinity</code>规范(<code>preferredDuringSchedulingIgnoredDuringExecution</code>，更多细节请参见这里的<a href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#inter-pod-affinity-and-anti-affinity-beta-feature" target="_blank" rel="noopener"/>)，所以我们没有在相同的主机名(<code>topologyKey: kubernetes.io/hostname</code>)上调度pod。</p>
<h2 class="translated"><a id="8-specify-a-pod-disruption-budget-pdb" class="anchor" href="#8-specify-a-pod-disruption-budget-pdb" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a> 8。指定Pod中断预算(PDB)</h2>
<p class="translated">在Kubernetes，豆荚有一个有限的寿命，可以随时终止。这种现象被称为<a href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/" target="_blank" rel="noopener">【颠覆】</a>。</p>
<p class="translated">中断可能是自愿的，也可能是非自愿的。顾名思义，非自愿中断是指任何人都无法预料到的事情(例如硬件故障)。主动中断是由某人或某事发起的，如节点升级、新部署等。</p>
<p class="translated">定义“Pod中断预算”有助于Kubernetes在发生自愿中断时管理您的Pod。Kubernetes将努力确保与给定选择器匹配的足够多的资源同时保持可用。指定一个<a href="https://kubernetes.io/docs/tasks/run-application/configure-pdb/" target="_blank" rel="noopener"> PDB </a>可以提高服务的可用性。</p>
<h2 class="translated"><a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"> <svg aria-hidden="true" class="octicon octicon-link" version="1.1" viewbox="0 0 16 16"> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/> </svg> </a>结论</h2>
<div id="__next">
<div>
<p> </p>
<article class="w-100p maw-900 m-auto">
<div class="mb-80 css-dr1l82">
<p class="translated">四年前，我们使用这些优秀的默认设置，并将它们应用到我们在Kubernetes的所有应用程序中。我们建议您根据应用程序和工作负载的具体情况调整实践。</p>
<p class="translated">您可以在培训的<a href="https://github.com/algolia/kubernetes-hands-on/tree/master/99-good-practices">专门部分找到关于这些良好实践的更多详细信息。</a></p>
</div>
</article>
<p> </p>
</div>
</div>
</div></div>    
</body>
</html>